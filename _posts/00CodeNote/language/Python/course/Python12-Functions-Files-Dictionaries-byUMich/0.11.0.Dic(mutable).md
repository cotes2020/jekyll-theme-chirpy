
# dic

[toc]

# intro

The compound data types:
- strings and lists
  - are sequential collections.
  - means that the items in the collection are ordered from left to right, use integers as indices to access the values they contain.
  - also means that looking for a particular value requires scanning the many items in the list until you find the desired value.
- Dictionary
  - different kind of collection.
  - Pythonâ€™s built-in `mapping` type.
  - A map is an `unordered, associative` collection.
  - from a `key` (any immutable type), to a `value` (any Python data object).
  - å¯å˜å®¹å™¨æ¨¡å‹ï¼Œä¸”å¯å­˜å‚¨ä»»æ„ç±»å‹å¯¹è±¡ã€‚
  - å­—å…¸çš„æ¯ä¸ªKEYå€¼(key=>value)å¯¹ç”¨å†’å·(:)åˆ†å‰²ï¼Œæ¯ä¸ªå¯¹ä¹‹é—´ç”¨é€—å·(,)åˆ†å‰²ï¼Œæ•´ä¸ªå­—å…¸åŒ…æ‹¬åœ¨èŠ±æ‹¬å·({})ä¸­

`d = {key1 : value1, key2 : value2 }`

- KEYå¿…é¡»æ˜¯å”¯ä¸€çš„ï¼Œä½†å€¼åˆ™ä¸å¿…ã€‚
- å€¼å¯ä»¥å–ä»»ä½•æ•°æ®ç±»å‹ï¼Œä½†KEYå¿…é¡»æ˜¯ä¸å¯å˜çš„ï¼Œå¦‚å­—ç¬¦ä¸²ï¼Œæ•°å­—æˆ–å…ƒç»„ã€‚

to create a dictionary:
- It doesnâ€™t matter what order to write the pairs.
- The values in a dictionary are accessed with keys, not with indices, no need to care about ordering.

1. start with the empty dictionary, add key-value pairs.
    - The empty dictionary is denoted {}.

      ```py
      1	eng2sp = {}
      2	eng2sp['one'] = 'uno'
      3	eng2sp['two'] = 'dos'
      4	eng2sp['three'] = 'tres'

      {'one': 'uno', 'two': 'dos', 'three': 'tres'}
      ```
2. to provide a bunch of key-value pairs
    - It doesnâ€™t matter what order we write the pairs.

      ```py
      1	eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
      ```


## è®¿é—®å­—å…¸é‡Œçš„å€¼
- æŠŠç›¸åº”çš„KEYæ”¾å…¥åˆ°æ–¹æ‹¬å·ä¸­ `dict['Key']`

```py
dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
print ("dict['Name']: ", dict['Name'])
print ("dict['Age']: ", dict['Age'])

# ç»“æœ
dict['Name']:  Runoob
dict['Age']:  7

# å¦‚æœç”¨å­—å…¸é‡Œæ²¡æœ‰çš„KEYè®¿é—®æ•°æ®ï¼Œä¼šè¾“å‡ºé”™è¯¯å¦‚ä¸‹ï¼š
print ("dict['Alice']: ", dict['Alice'])

# ç»“æœ
Traceback (most recent call last):
  File "test.py", line 5, in <module>
    print ("dict['Alice']: ", dict['Alice'])
KeyError: 'Alice'
```

## æ›´æ–°/æ·»åŠ  `dict['new/key']=new/value`
- æ·»åŠ æ–°å†…å®¹: å¢åŠ æ–°çš„KEY/å€¼å¯¹ï¼Œä¿®æ”¹æˆ–åˆ é™¤å·²æœ‰KEY/å€¼å¯¹

```py
dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}

dict['Age'] = 8               # æ›´æ–° Age
dict['School'] = "AAA"        # æ·»åŠ ä¿¡æ¯

print ("dict['Age']: ", dict['Age'])
print ("dict['School']: ", dict['School'])

# ç»“æœ
dict['Age']:  8
dict['School']:  AAA
```

---

## Looping

### Looping Through All Key-Value Pairs

```py
user_0 = {'username': 'efermi',
          'first': 'enrico', 'last': 'fermi',
         }

for key, value in user_0.items():
    print(f"\nKey: {key}")
    print(f"Value: {value}")
```


### Looping Through All the Keys in a Dictionary

```py
for name in favorite_languages.keys():
    print(name.title())
```

### Looping Through Keys in a Particular Order

```py
for name in sorted(favorite_languages.keys()):
    print(f"{name.title()}, thank you for taking the poll.")
```

### Looping Through All Values in a Dictionary

```py
for language in favorite_languages.values():
    print(language.title())
```

---

## åˆ é™¤VALUE `del` dict['key']
- èƒ½åˆ å•ä¸€çš„å…ƒç´ ä¹Ÿèƒ½æ¸…ç©ºå­—å…¸ï¼Œæ¸…ç©ºåªéœ€ä¸€é¡¹æ“ä½œã€‚

```py
dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}

del dict['Name'] # åˆ é™¤KEY 'Name'
dict.clear()     # æ¸…ç©ºå­—å…¸
del dict         # åˆ é™¤å­—å…¸

# æ‰§è¡Œ del æ“ä½œåå­—å…¸ä¸å†å­˜åœ¨ï¼š
print ("dict['Age']: ", dict['Age'])

Traceback (most recent call last):
  File "test.py", line 9, in <module>
    print ("dict['Age']: ", dict['Age'])
TypeError: 'type' object is not subscriptable
```

---


## å­—å…¸KEYçš„ç‰¹æ€§
- å­—å…¸å€¼å¯ä»¥æ˜¯ä»»ä½•çš„ python å¯¹è±¡ï¼Œæ—¢å¯ä»¥æ˜¯æ ‡å‡†çš„å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥æ˜¯ç”¨æˆ·å®šä¹‰çš„ï¼Œä½†KEYä¸è¡Œã€‚

1. ä¸å…è®¸åŒä¸€ä¸ªKEYå‡ºç°ä¸¤æ¬¡ã€‚å¦‚åŒä¸€ä¸ªKEYè¢«èµ‹å€¼ä¸¤æ¬¡ï¼Œåä¸€ä¸ªå€¼ä¼šè¢«è®°ä½

```py
dict = {'Name': 'Runoob', 'Age': 7, 'Name': 'Pig'}
print ("dict['Name']: ", dict['Name'])
# ç»“æœ
dict['Name']:  Pig
```

2. KEYå¿…é¡»ä¸å¯å˜ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ *æ•°å­—ï¼Œå­—ç¬¦ä¸²æˆ–å…ƒç»„* å……å½“ï¼Œ*åˆ—è¡¨* å°±ä¸è¡Œï¼Œå¦‚ä¸‹å®ä¾‹ï¼š

```py
dict = {['Name']: 'Runoob', 'Age': 7}
print ("dict['Name']: ", dict['Name'])
# tuple ok:

# dict = {('Name'): 'Runoob', 'Age': 7}
# print ("dict('Name'): ", dict[('Name')])
# ç»“æœ
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    dict = {['Name']: 'Runoob', 'Age': 7}
TypeError: unhashable type: 'list'
```

--

## æ–¹æ³•

###	`len`(dict): KEYçš„æ€»æ•°ã€‚

returns the number of key-value pairs.

```py
>>> dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
>>> len(dict)
3
```

2.	str(dict): è¾“å‡ºå­—å…¸ï¼Œä»¥å¯æ‰“å°çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚

```py
>>> dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
>>> str(dict)
"{'Name': 'Runoob', 'Class': 'First', 'Age': 7}"
```

3.	type(variable): è¿”å›è¾“å…¥çš„å˜é‡ç±»å‹ï¼Œå¦‚æœå˜é‡æ˜¯å­—å…¸å°±è¿”å›å­—å…¸ç±»å‹ã€‚

```py
>>> dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
>>> type(dict)
<class 'dict'>
```

---

## å†…ç½®æ–¹æ³•ï¼š

###	dict.`clear()`: åˆ é™¤å­—å…¸å†…æ‰€æœ‰å…ƒç´ 

```py
>>> dict = {'Name': 'Zara', 'Age': 7}
>>> dict.clear()
>>> print (len(dict))
0
```

###	dict.`copy()`: è¿”å›ä¸€ä¸ªå­—å…¸çš„æµ…å¤åˆ¶

```py
>>> dict1 = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
>>> dict2 = dict1.copy()
>>> print ("æ–°å¤åˆ¶çš„å­—å…¸ä¸º: ",dict2)
('\xe6\x96\xb0\xe5\xa4\x8d\xe5\x88\xb6\xe7\x9a\x84\xe5\xad\x97\xe5\x85\xb8\xe4\xb8\xba : ', {'Age': 7, 'Name': 'Runoob', 'Class': 'First'})

1. ç›´æ¥èµ‹å€¼ å’Œ copy çš„åŒºåˆ«

  dict1 =  {'user':'runoob','num':[1,2,3]}
  dict2 = dict1          # æµ…æ‹·è´: å¼•ç”¨å¯¹è±¡
  dict3 = dict1.copy()   # æµ…æ‹·è´ï¼šæ·±æ‹·è´çˆ¶å¯¹è±¡ï¼ˆä¸€çº§ç›®å½•ï¼‰ï¼Œå­å¯¹è±¡ï¼ˆäºŒçº§ç›®å½•ï¼‰ä¸æ‹·è´ï¼Œè¿˜æ˜¯å¼•ç”¨

  # ä¿®æ”¹ data æ•°æ®
  dict1['user']='root'
  dict1['num'].remove(1)

  # è¾“å‡ºç»“æœ
  print(dict1)
  print(dict2)
  print(dict3)
  #dict2 æ˜¯ dict1 çš„å¼•ç”¨ï¼ˆåˆ«åï¼‰ï¼Œæ‰€ä»¥è¾“å‡ºç»“æœéƒ½æ˜¯ä¸€è‡´çš„
  #dict3 çˆ¶å¯¹è±¡è¿›è¡Œäº†æ·±æ‹·è´ï¼Œä¸ä¼šéšdict1 ä¿®æ”¹è€Œä¿®æ”¹ï¼Œå­å¯¹è±¡æ˜¯æµ…æ‹·è´æ‰€ä»¥éš dict1 çš„ä¿®æ”¹è€Œä¿®æ”¹ã€‚
  {'user': 'root', 'num': [2, 3]}
  {'user': 'root', 'num': [2, 3]}
  {'user': 'runoob', 'num': [2, 3]}
```

---

###	dict.`fromkeys(seq[, value])`: åˆ›å»ºä¸€ä¸ªæ–°å­—å…¸
  - ä»¥åºåˆ—seqä¸­å…ƒç´ åšå­—å…¸çš„KEY
  - valä¸ºå­—å…¸æ‰€æœ‰KEYå¯¹åº”çš„åˆå§‹å€¼

```py
>>> seq = ('name', 'age', 'sex')

>>> dict = dict.fromkeys(seq)               # ä¸æŒ‡å®šå€¼ï¼š
>>> print ("æ–°çš„å­—å…¸ä¸º : %s" %  str(dict))

>>> dict = dict.fromkeys(seq, 10)          # every key's value is the same
>>> print ("æ–°çš„å­—å…¸ä¸º : %s" %  str(dict))

>>> # ç»“æœ
>>> æ–°çš„å­—å…¸ä¸º : {'age': None, 'name': None, 'sex': None}    # ä¸æŒ‡å®šå€¼ï¼šall None
>>> æ–°çš„å­—å…¸ä¸º : {'age': 10, 'name': 10, 'sex': 10}          # every key's value is the same
```

---

## Access Values

### dict.`get(key, default=None)`: è¿”å›æŒ‡å®šKEYçš„å€¼ï¼Œå¦‚æœå€¼ä¸åœ¨å­—å…¸ä¸­è¿”å›defaultå€¼

```py

1.

    inventory = {'BigBlueberry': 430, 'bananas': 312, 'oranges': 525, 'pears': 217}

    print(inventory.get("Bigblueberrys"))     # 430
    print(inventory.get("cherries"))   # None
    print(inventory.get("cherries",0)) # 0


2.

    di = [{"Puppies": 17, 'Kittens': 9, "Birds": 23, 'Fish': 90, "Hamsters": 49}, {"Puppies": 23, "Birds": 29, "Fish": 20, "Mice": 20, "Snakes": 7}, {"Fish": 203, "Hamsters": 93, "Snakes": 25, "Kittens": 89}, {"Birds": 20, "Puppies": 90, "Snakes": 21, "Fish": 10, "Kittens": 67}]
    total=0

    for dict in di:
        total += dict.get("Puppies",0)
    print(total)

```

---

### ç”±valueæŸ¥æ‰¾key

list(student.keys()) [ list(student.values()).index ('1004')]

ç»“æœæ˜¾ç¤ºï¼š 'å°æ˜'


---

### x`.keys()`: view of the keys in dic

x`.keys()` actually do produce lists.
- but In a native python interpreter,  `type(inventory.keys())` something not actual list.

```py

1.
      inventory = {'BigBlueberry': 430, 'bananas': 312, 'oranges': 525, 'pears': 217}

      for akey in inventory.keys(): # the order in which we get the keys is not defined
          print(akey)
      Bigblueberrys
      bananas
      oranges
      pears

      >>> list(inventory.keys())
      ['BigBlueberry', 'bananas', 'oranges', 'pears']

2. dict.keys(): è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä½¿ç”¨ list() æ¥è½¬æ¢ä¸ºåˆ—è¡¨
    - ç›´æ¥ä½¿ç”¨dict.keys()ï¼Œé‚£ä¹ˆè¿”å›å€¼ä¸ºdict_keysï¼Œå¹¶éç›´æ¥çš„åˆ—è¡¨
    - è‹¥è¦è¿”å›åˆ—è¡¨å€¼è¿˜éœ€è°ƒç”¨listå‡½æ•°ã€‚

      >>> dict = {'Name': 'Runoob', 'Age': 7}

      >>> dict.keys()
      dict_keys(['Name', 'Age'])

      >>> list(dict.keys())  # è½¬æ¢ä¸ºåˆ—è¡¨
      ['Name', 'Age']
```

to iterate over the keys in a dictionary
- omit the `keys()`, use `for` loop
- iterating over a dictionary implicitly iterates over its keys.

```py

    inventory = {'BigBlueberry': 430, 'bananas': 312, 'oranges': 525, 'pears': 217}
    for k in inventory:
        print(k)
    Bigblueberrys
    bananas
    oranges
    pears
```

---

###	`key in / not in dict`: å¦‚æœKEYåœ¨å­—å…¸dicté‡Œè¿”å›trueï¼Œå¦åˆ™è¿”å›false

```py
inventory = {'BigBlueberry': 430, 'bananas': 312, 'oranges': 525, 'pears': 217}
print('BigBlueberry' in inventory)   # True
print('cherries' in inventory) # False

if 'bananas' in inventory:
    print(inventory['bananas'])
else:
    print("We have no bananas")
312

mydict = {"cat":12, "dog":6, "elephant":23, "bear":20}
print(23 in mydict)
False
# 23 is a value in the dictionary, not a key.
```

---

###	dict.`items()`: ä»¥åˆ—è¡¨è¿”å›å¯éå†çš„(KEY, å€¼) å…ƒç»„æ•°ç»„

```py
>>> abc = {'Name': 'Runoob', 'Age': 7}
>>> print (abc.items())
[('Age', 7), ('Name', 'Runoob')]

- éå†ä¾‹å­ï¼š
  >>> dict = {'Name': 'Runoob', 'Age': 7}
  >>> for i,j in dict.items():
  >>>    print(i, ":\t", j)
  Name :   Runoob
  Age :    7

- å°†å­—å…¸çš„ key å’Œ value ç»„æˆä¸€ä¸ªæ–°çš„åˆ—è¡¨ï¼š
  >>> d={1:"a",2:"b",3:"c"}
  >>> result=[]
  >>> for k,v in d.items():
  >>>    result.append(k)
  >>>    result.append(v)
  >>>    print(result)
  [1, 'a', 2, 'b', 3, 'c']
```

8.	dict.`setdefault(key, default=None)`: å’Œget()ç±»ä¼¼, ä½†å¦‚æœKEYä¸å­˜åœ¨äºå­—å…¸ä¸­ï¼Œå°†ä¼šæ·»åŠ KEYå¹¶å°†å€¼è®¾ä¸ºdefault
>>> dict = {'Name': 'Runoob', 'Age': 7}
>>> print ("Age é”®çš„å€¼ä¸º : %s" %  dict.setdefault('Age', None))
>>> print ("Sex é”®çš„å€¼ä¸º : %s" %  dict.setdefault('Sex', None))
>>> print ("æ–°å­—å…¸ä¸ºï¼š", dict)
Age é”®çš„å€¼ä¸º : 7
Sex é”®çš„å€¼ä¸º : None
æ–°å­—å…¸ä¸ºï¼š {'Age': 7, 'Name': 'Runoob', 'Sex': None}


9.	dict.`update(dict2)`: æŠŠå­—å…¸dict2çš„KEY/å€¼å¯¹æ›´æ–°åˆ°dicté‡Œ
è¿”å›å€¼: è¯¥æ–¹æ³•æ²¡æœ‰ä»»ä½•è¿”å›å€¼ã€‚
>>> dict = {'Name': 'Runoob', 'Age': 7}
>>> dict2 = {'Sex': 'female' }
>>> dict.update(dict2)
>>> print ("æ›´æ–°å­—å…¸ dict : ", dict)
æ›´æ–°å­—å…¸ dict :  {'Name': 'Runoob', 'Age': 7, 'Sex': 'female'}



11.	dict.`pop(key[,default])`: åˆ é™¤å­—å…¸ç»™å®šKEY key æ‰€å¯¹åº”çš„å€¼ï¼Œè¿”å›å€¼ä¸ºè¢«åˆ é™¤çš„å€¼ã€‚
- keyå€¼å¿…é¡»ç»™å‡ºã€‚ å¦åˆ™ï¼Œè¿”å›defaultå€¼ã€‚
- æ‹¬å·é‡Œæ²¡æœ‰å‚æ•°: åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ , 0: åˆ é™¤æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
>>> site= {'name': 'èœé¸Ÿæ•™ç¨‹', 'alexa': 10000, 'url': 'www.runoob.com'}
>>> pop_obj=site.pop('name')
>>> print(pop_obj)
èœé¸Ÿæ•™ç¨‹
>>> print(site)
{'url': 'www.runoob.com', 'alexa': 10000}

  - å¦‚æœè¦åˆ é™¤çš„ key ä¸å­˜åœ¨ï¼Œåˆ™éœ€è¦æ·»åŠ é»˜è®¤å€¼ï¼Œå¦åˆ™ä¼šæŠ¥é”™ï¼š
  >>> dict1 = {1: "a", 2: [1, 2]};

  >>> print(dict1.pop(1),dict1);
  a {2: [1, 2]}

  >>> print(dict1.pop(3,"nokey"),dict1);    # è®¾ç½®é»˜è®¤å€¼ï¼Œå¿…é¡»æ·»åŠ ï¼Œå¦åˆ™æŠ¥é”™
  nokey {2: [1, 2]}

  >>> print(dict1.pop(3),dict1);
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  KeyError: 3

###	`popitem()`: éšæœºè¿”å›å¹¶åˆ é™¤å­—å…¸ä¸­çš„æœ€åä¸€å¯¹KEYå’Œå€¼ã€‚
>>> site= {'name': 'èœé¸Ÿæ•™ç¨‹', 'alexa': 10000, 'url': 'www.runoob.com'}
>>> pop_obj=site.popitem()
>>> print(pop_obj)
('url', 'www.runoob.com')
>>> print(site)
{'name': 'èœé¸Ÿæ•™ç¨‹', 'alexa': 10000}


### dic`.value()` return the objects
è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¯ä»¥ä½¿ç”¨ list() æ¥è½¬æ¢ä¸ºåˆ—è¡¨
- the item objects are `tuples` containing the key and the associated value.

```py
inventory = {'BigBlueberry': 430, 'bananas': 312, 'oranges': 525, 'pears': 217}

print(list(inventory.values()))
[430, 312, 525, 217]

print(list(inventory.items()))  # the item objects are tuples
[('BigBlueberry', 430), ('bananas', 312), ('oranges', 525), ('pears', 217)]

for k in inventory:
    print("Got",k,"that maps to",inventory[k])
Got Bigblueberrys that maps to 430
Got bananas that maps to 312
Got oranges that maps to 525
Got pears that maps to 217
```

---

## 11.5. Aliasing and copying

dictionaries are mutable, be aware of `aliasing`.

```py

1. Aliasing.

    opposites = {'up': 'down', 'right': 'wrong', 'true': 'false'}
    alias = opposites
    # alias and opposites refer to the same object.
    print(alias is opposites) # True

2. dic.copy():
   a copy of the dictionary, changes to it will not effect the original.

    acopy = opposites.copy()
    acopy['right'] = 'left'
    # does not change opposites
```

---


## 11.9. ğŸ‘©â€ğŸ’» When to use a dictionary
when a dictionary will be beneficial:

- When a piece of data consists of `a set of properties of a single item`, a dictionary is often better. You could try to keep track mentally that the zip code property is at index 2 in a list, but your code will be easier to read and you will make fewer mistakes if you can look up mydiction[â€˜zipcodeâ€™] than if you look up mylst[2].

- When you have a `collection of data pairs`, and you will often have to look up one of the pairs based on its first value, it is better to use a dictionary than a list of (key, value) tuples. With a dictionary, you can find the value for any (key, value) tuple by looking up the key. With a list of tuples you would need to iterate through the list, examining each pair to see if it had the key that you want.

- but, if a collection of data pairs where multiple pairs share the same first data element, then you canâ€™t use a dictionary, because a dictionary requires all the keys to be distinct from each other.


---

## example:

### 11.6. Accumulating Multiple Results In a Dictionary è®¡ç®—strä¸­å­—æ¯æ¬¡æ•°

`the accumulator pattern`:
- goes through the items in a sequence, updating an `accumulator variable` each time.
- Rather than accumulating a single result, itâ€™s possible to accumulate many results.

```py
stri = "what can I do"
char_d={}
for i in stri:
    if i not in char_d:
        char_d[i]=0     # create key
    char_d[i]+=1        # raise the key's value
```


```py
f = open('scarlet.txt', 'r')
txt = f.read()
# now txt is one long string containing all the characters
x = {}      # start with an empty dictionary
x['t'] = 0  # intiialize the t counter
x['s'] = 0  # initialize the s counter
for c in txt:
    if c == 't':
        x[c] = x[c] + 1   # increment the t counter
    elif c == 's':
        x[c] = x[c] + 1   # increment the s counter

print("t: " + str(x['t']) + " occurrences")
print("s: " + str(x['s']) + " occurrences")


2. nice thing about using a dictionary: donâ€™t have to prespecify what all the letters will be.

    f = open('scarlet.txt', 'r')
    txt = f.read()
    # now txt is one long string containing all the characters
    x = {} # start with an empty dictionary
    for c in txt:
        if c not in x:
            # not seen this character before, so initialize a counter for it
            x[c] = 0

        #whether we've seen it before or not, increment its counter
        x[c] = x[c] + 1

    print("t: " + str(x['t']) + " occurrences")
    print("s: " + str(x['s']) + " occurrences")

    for c in x.keys():
    print(c + ": " + str(x[c]) + " occurrences")


3. compute the total score

    letter_values = {'a': 1, 'b': 3, 'c': 3, 'd': 2, 'e': 1, 'f':4, 'g': 2, 'h':4, 'i':1, 'j':8, 'k':5, 'l':1, 'm':3, 'n':1, 'o':1, 'p':3, 'q':10, 'r':1, 's':1, 't':1, 'u':1, 'v':8, 'w':4, 'x':8, 'y':4, 'z':10}

    tot = 0
    for y in x:
        if y in letter_values:
            tot = tot + letter_values[y] * x[y]

    print(tot)


    schedule = {"UARTS 150": 3, "SPANISH 103": 4, "ENGLISH 125": 4, "SI 110": 4, "ENS 356": 2, "WOMENSTD 240": 4, "SI 106": 4, "BIO 118": 3, "SPANISH 231": 4, "PSYCH 111": 4, "LING 111": 3, "SPANISH 232": 4, "STATS 250": 4, "SI 206": 4, "COGSCI 200": 4, "AMCULT 202": 4, "ANTHRO 101": 4}
    total_credits=0
    for i in schedule:   # all the key in dic
        total_credits+=schedule[i]

```

---

### 11.8. Accumulating the Best Key è®¡ç®—valueçš„æœ€å€¼

```py

1.

    d = {'a': 194, 'b': 54, 'c':34, 'd': 44, 'e': 312, 'full':31}
    ks = d.keys()
    maxnum=0
    for k in ks:
        if maxnum<d[k]:
            maxnum=d[k]
            best_key_so_far=k
    print("key " + best_key_so_far + " has the highest value, " + str(d[best_key_so_far]))

2.

    best_key_so_far = list(ks)[0]
    # turn ks into a real list before using [] to select an item
    for k in ks:
        if d[k] > d[best_key_so_far]:
            best_key_so_far = k

    print("key " + best_key_so_far + " has the highest value, " + str(d[best_key_so_far]))

```

### translate the str

```py
dic={'hello':'avast', 'sir':'matey', 'hotel':'fleabag inn', 'student':'swabbie', 'boy':'matey'}

user_s='hello boy'

new_s=''
psentence = []

user_w=user_s.split()
for i in user_w:
    if i in dic:
      new_s+=dic[i]+' '
      psentence.append(dic[i])
    else:
      psentence.append(aword)
print(" ".join(psentence))
```

---

### dic according to the alphabet

```py
x = input("Enter a sentence")
x = x.lower()   # convert to all lowercase

alphabet = 'abcdefghijklmnopqrstuvwxyz'

letter_count = {} # empty dictionary

for char in x:
    if char in alphabet:
    # ignore any punctuation, numbers, etc
        if char in letter_count:
            letter_count[char] += 1
        else:
            letter_count[char] = 1

keys = letter_count.keys()
for char in sorted(keys):  # æ’åˆ—
    print(char, letter_count[char])
```



freq = {}
for c in str1:
    if c not in freq:
        freq[c] = 0
    freq[c]+=1


freq={}

for i in str1:
    if i not in frep:
        frep[i]=0
    frep[i]+=1


.
