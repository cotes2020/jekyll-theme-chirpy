---
title: TCP-UDP 통신
author: littley
date: 2023-06-08 00:00:00 +0900
categories: [CS, Network]
tags : [Network]
img_path : 'assets/img/posts/TCP-UDP'
---

## TCP란?

Transmission Control Protocol의 약자로, **신뢰성 있는 데이터 통신**을 가능하게 해주는 프로토콜이다. 4계층인 Transport Layer(전송 계층)에서 사용하며 특징으로는 다음과 같은 것들이 있다.

- 양방향 통신 지원 **(3 & 4 way-handshake)**
- 데이터의 순차 전송 보장
- Flow Control (흐름 제어)
- Congestion Control (혼잡 제어)
- Error Detection (오류 감지) → 오류가 감지되면 전체 세그먼트를 재전송한다.

네트워크 계층의 패킷처럼, 전송 계층에는 **세그먼트**(Segment)가 있다. 데이터와 TCP Header가 결합된 형태다. 데이터를 나누어서 전송하기 때문에 나눠진 데이터마다 TCP Header가 존재한다.

### TCP Header

![TCP 헤더에 있는 다양한 정보.](Untitled 11.png)

TCP 헤더에 있는 다양한 정보.

한 헤더는 일반적으로 `20byte` 크기로 되어있다(옵션 설정에 때라 최대 `60byte`까지 가능하다). 각 필드의 비트를 0 혹은 1로 변경하여 전송하고자 하는 세그먼트의 정보를 나타낸다.

- 처음은 **세그먼트의 출발지와 목적지**를 나타내는 필드다. IP 주소 정보는 한 계층 아래인 네트워크 계층에 존재하기 때문에, 여기에는 컴퓨터의 프로세스가 도착해야 할 포트 번호가 들어간다.
- 다음은 **시퀀스 번호**로 전송하는 데이터의 순서를 의미한다. 송신자가 최초로 번호를 보낼 때 랜덤한 수로 초기화하고, `1byte` 데이터를 전송할 때 마다 시퀀스 번호를 1씩 증가시킨다. `4,294,967,296`까지 담을 수 있으므로 번호가 중복될 위험은 거의 없다.
- 그 다음 **승인 번호**는 수신자가 예상하는 다음 시퀀스 번호를 의미한다. 연결 설정과 해제때 발생하는 **Handshake** 과정에서는 송신자 시퀸스 번호 + 1로 자신의 승인 번호를 만들어내고, 데이터를 주고받을 때는 송신자 시퀸스 번호 + 자신이 받은 데이터의 `byte`로 승인 번호를 만든다.
- 데이터 오프셋 필드는 헤더가 아닌 데이터가 실제 시작되는 위치를 표시한다. 32비트 워드 단위를 사용해 `1 Word = 4 bytes`로 해석한다. 기본 헤더 크기인 `5 Word = 20bytes`가 최소값이고, 옵션의 크기에 따라 오프셋을 결정한다.
- 리저브 필드는 미래를 위해 예약된 필드로 모두 0으로 채워져 있어야 한다.
- 다음은 9개의 비트 플래그로 현재 세그먼트의 속성을 나타낸다. **3 & 4 way-handshake**는 수신자와 송신자가 이 플래그를 확인하는 방식으로 구현되어 있다.
- 윈도우 사이즈 필드는 한번에 전송할 수 있는 데이터의 양을 의미한다.
- 체크섬은 데이터를 주고받을 때 발생할 수 있는 오류를 검출하기 위한 값이다.
- 긴급 포인터 필드는 켜져있을 경우 이 포인터가 가르키고 있는 데이터를 우선 처리한다.

## 3 & 4 Way-Handshake

TCP 하에서 데이터를 주고받을 때 사용되는 방식이다. 연결을 생성할 때는 3번의 통신 과정을 거치기 때문에 3 Way, 연결을 종료할 때는 4번의 통신 과정을 거치기 때문에 4 Way이다.

주로 쓰이는 플래그로는 **SYN**(Synchronize Sequence Number), **ACK**(Acknowledgment), **FIN**(Finish) 3가지다. SYN은 위의 시퀀스 번호 필드를 동기화하는 작업이고, ACK는 특정 플래그를 인식했다는 의미고, FIN은 연결을 종료하겠다는 의미다.

### 연결 생성(3 Way)

![Untitled](Untitled 12.png)

1. 클라이언트는 서버에 접속을 요청하는 `SYN` 플래그를 켜고 세그먼트를 보낸다. 이때 클라는 `SYN`을 보내고 `SYN/ACK` 응답을 기다리는 `SYN_SENT` 상태가 된다.
2. 서버는 `SYN` 요청을 받고, 요청을 수락한다는 의미로 클라에게 `ACK SYN`플래그를 모두 켜서 세그먼트를 보낸 다음, 다시 클라가 `ACK`로 응답하기를 기다린다. 이때 서버는 `SYN_RECIEVED` 상태가 된다.
3. 클라가 서버에게 `ACK`를 보내면 두 컴퓨터간의 연결이 생성된 것이다. 이때 서버의 상태가 `ESTABLISHED`가 된다.

### 연결 종료(4 Way)

![Untitled](Untitled 13.png)

1. 클라가 서버에게 `FIN` 플래그를 전송한다.
2. 서버는 `ACK`를 보내고, 자신의 통신이 끝날때까지 기다린다(`CLOSE_WAIT`).
3. 서버가 통신이 끝났으면, 클라에게 연결이 종료되었다고 `FIN` 플래그를 전송한다.
4. 클라이언트는 확인했다는 신호 `ACK`를 보낸다.

다만 모종의 이유로 서버가 보낸 `FIN`가 전송해야 하는 데이터 패킷보다 빠르게 도착할 수 있다. 이 때 패킷이 소실되는 것을 막기 위해서, 클라이언트는 연결을 종료하기 전에 일정 시간 연결된 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. 이 과정을 `TIME_WAIT`이라고 한다.

---

## UDP란?

전송의 신뢰성을 담보해주는 TCP지만, 그만큼 성능적인 문제가 발생했다. 

1. 데이터를 주고받을 때마다 매번 연결을 해야하고, 
2. 수신자가 온전한 데이터를 받지 못하면 전체 데이터를 다시 재전송해야 한다. 

중요한 데이터의 경우에는 이 방법이 좋지만, 데이터 보장보다 전송 속도가 중요한 서비스에서는 다른 방식을 사용할 필요가 있다. 그래서 등장한 것이 **UDP**(User Datagram Protocol)이다. UDP의 특징으로는

- 신뢰성이 떨어지지만 전송 속도가 일반적으로 빠른 프로토콜
- 비연결형 프로토콜
- Error Detection (checksum 이용)
- 비교적 데이터의 신뢰성이 중요하지 않을 때 사용한다(ex. 영상 스트리밍).

네트워크의 IP, TCP의 Segment가 있다면 UDP에는 **User Datagram**이 존재한다.

![Untitled](Untitled 14.png)

UDP 헤더는 출발지와 도착지 포트, 데이터그램의 길이, 오류 감지를 위한 체크섬만 존재한다. 심지어 오류 감지가 필수적인 TCP와 다르게, 송신자가 Checksum을 모두 0으로 송출하면 수신자는 오류 감지조차도 하지 않는다.

![Untitled](Untitled 15.png)

데이터 전송 또한 송신자는 수신자의 요청에 따라 유저 데이터그램을 보내주기만 하면 된다. 정말 끝이다.

---

## 마무리

![Untitled](Untitled 16.png)

Transport Layer의 대표적인 두 사례인 TCP와 UDP는 데이터 통신을 설계할 때 무엇을 우선적인 가치로 설정할 것인가에 따라 선택할 수 있는 프로토콜이다. 서비스에 따라 적절한 프로토콜을 선택해야 한다.

### 번외 - 언리얼 엔진

한편 **언리얼 엔진**은 TCP와 UDP를 모두 사용할 수 있지만, 기본적으로는 UDP 기반의 “**Unreal Networking Protocol**”이라는 고유 프로토콜을 사용한다. 데이터의 무결성 보다는 클라이언트와 서버간의 빠른 데이터 송수신이 더 중요하기 때문이다.

네트워크 멀티플레이어 게임은 **클라이언트-서버** 모델을 사용해 동작한다. 네트워크의 한 컴퓨터는 **서버** 역할을 하면서 게임 세션을 호스트하고, 다른 모든 플레이어의 컴퓨터는 **클라이언트**로 서버에 연결한다. 서버는 각 클라이언트와 게임 상태 정보를 공유하고 서로 통신할 수 있는 수단을 제공한다.

![Untitled](Untitled 17.png)

클라이언트는 서버가 소유하고 있는 폰을 원격으로 제어해서 게임 내 액션을 수행하도록 **프로시저 호출**을 보낸다. 만약 서버가 해당 클라이언트를 제외한 나머지 클라이언트 및 각각의 폰을 직접 스트리밍 해야 한다면 서버의 부하가 매우 커진다. 그 대신 서버는 `Game State`의 정보를 각 클라이언트에게 리플리케이트해서, 어떤 액터가 존재해야 하는 지, 그 액터가 어떻게 행동해야 하는 지, 다른 변수들이 어떤 값을 가져야 하는지 알려준다. 그러면 클라이언트는 이 정보를 사용해 **서버에서 발생하는 상황에 대한 매우 근접한 근사치**를 시뮬레이션 한다.

왜 언리얼이 UDP를 사용하는지 궁금했는데, 이번 기회로 정리가 잘 되었다.

---

## Reference

[[10분 테코톡] 👨‍🏫르윈의 TCP UDP](https://www.youtube.com/watch?v=ikDVGYp5dhg&t=679s)

[TCP의 헤더에는 어떤 정보들이 담겨있는걸까?](https://evan-moon.github.io/2019/11/10/header-of-tcp/)

[[ 네트워크 쉽게 이해하기 22편 ] TCP 3 Way-Handshake & 4 Way-Handshake](https://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-22편-TCP-3-WayHandshake-4-WayHandshake)

[Networking Overview](https://docs.unrealengine.com/5.1/en-US/networking-overview-for-unreal-engine/)