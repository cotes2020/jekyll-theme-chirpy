---
title: "认识阿里云「编排系统」"
date: 2020-12-30
permalink: /2020-12-30-bian-pai/
tags: [编排系统]
---

## 功能分析

1. 支持历史版本、日志等元信息，以及有运行统计数据
2. 支持串行和并行编排，并且可以互相嵌套
3. 对接阿里云其他业务，并将其作为模块功能接入进来
4. 用户在使用业务模块时（例如函数计算），会引导开通未此模块需要的功能和进行授权，体验非常丝滑

## 配置文件分析


和内部实现的「可编排BFF设计系统」（中间层接口编排系统）类似，编排的本质就是定义、维护和解析一份json配置文件。


第一张图对应的编排配置文件就是：


```json
{
    "actions": {
        "函数计算": {
            "type": "FC",
            "inputs": {
                "triggerType": "http",
                "method": "GET",
                "serviceName": "scf-server",
                "functionName": "scf-nodejs12",
                "region": "cn-shanghai",
                "connection": {
                    "connectionId": "/logic/1554718707364643/connectors/FC/connections/AliyunLogicComposerAccessingFCRole",
                    "content": "acs:ram::1554718707364643:role/aliyunlogiccomposeraccessingfcrole",
                    "connectionName": "AliyunLogicComposerAccessingFCRole"
                }
            },
            "runAfter": {}
        },
        "初始化变量": {
            "type": "InitializeVariable",
            "inputs": {
                "type": "String",
                "name": "abc"
            },
            "runAfter": {
                "函数计算": [
                    "Succeeded"
                ]
            }
        },
        "通过自定义机器人发送消息": {
            "type": "DingTalk::SendMessageViaChatbot",
            "inputs": {
                "accessToken": "的广泛发动更多风格",
                "content": "dfgdfgdfgdfgdfg"
            },
            "runAfter": {
                "执行_JavaScript_代码": [
                    "Succeeded"
                ]
            }
        },
        "执行_JavaScript_代码": {
            "type": "JavascriptCode",
            "inputs": {
                "code": "const text = $context.concat('Hello', 'world');\nreturn text;"
            },
            "runAfter": {
                "函数计算": [
                    "Succeeded"
                ]
            }
        }
    },
    "triggers": {
        "manual": {
            "type": "Request",
            "inputs": {
                "method": "GET",
                "authentication": "None",
                "queriesSchema": {
                    "type": "object",
                    "properties": {},
                    "required": []
                }
            }
        }
    },
    "schemaVersion": "2018-12-12",
    "version": "1.0.0"
}

```


可以看到，配置文件中有2个重要属性：actions和triggers

- actions：定义每一步的元信息（inputs），以及触发条件（runAfter）
- triggers：定义编排整体的触发条件，例如通过HTTP请求触发、定时触发、服务触发

> actions结构设计的巧妙之处

1. 每个action都在actions下的第一个层级，没有像回调地狱那样的嵌套（得益于runAfter）
2. actions是对象结构，通过action标识读action配置速度快
3. aciton上的runAfter设计非常巧妙，基于事件的模型设计思路

## 实现原理分析


通过配置文件，大概能看出来实现的原理：

- 解析器解析actions配置，并且将每个action通过runAfter串连起来。
- 通过triggers定义，将其接入http服务或者设置定时任务
- actions整体触发的时候，负责执行的执行器将第一步解析结果进行执行

