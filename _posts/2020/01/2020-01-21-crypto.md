---
title: "NodeJS 加密模块 crypto"
date: 2020-01-21
permalink: /2020-01-21-crypto/
---
## 概述


这次研究下 nodejs 的 crypto 模块，它提供了各种各样加密算法的 API。这篇文章记录了常用加密算法的种类、特点、用途和代码实现。其中涉及算法较多，应用面较广，每类算法都有自己适用的场景。为了使行文流畅，列出了本文记录的几类常用算法：

- 内容摘要：散列(Hash)算法
- 内容摘要：HMac 算法
- 内容加解密：对称加密(AES)与非对称加密解密(RSA)
- 内容签名：签名和验证算法

## 散列(Hash)算法


散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。基本原理是将任意长度数据输入，最后输出固定长度的结果。


hash 算法具有以下特点：

- 不能从 hash 值倒推原数据
- 不同的输入，会有不同的输出
- 好的 hash 算法冲突概率更低

正因为 hash 算法的这些特点，因此 hash 算法主要用于：加密、数据检验、版本标识、负载均衡、分布式（一致性 hash）。


下面实现了一个获取文件标识的函数：


```typescript
const crypto = require("crypto");
const fs = require("fs");
function getFileHash(file, algorithm) {
    if (!crypto.getHashes().includes(algorithm)) {
        throw new Error("不支持此哈希函数");
    }
    return new Promise(resolve => {
        const hash = crypto.createHash(algorithm);
        const rs = fs.createReadStream(file);
        rs.on("readable", () => {
            const data = rs.read();
            if (data) {
                hash.update(data);
            }
        });
        rs.on("end", () => {
            resolve(hash.digest("hex"));
        });
    });
}
// 用法：获取文件md5
getFileHash("./db.json", "md5").then(val => {
    console.log(val);
})
```


## HMac 算法


攻击者可以借助“彩虹表”来破解哈希表。应对彩虹表的方法，是给密码加盐值（salt），将 pwd 和 salt 一起计算 hash 值。其中，salt 是随机生成的，越长越好，并且需要和用户名、密码对应保存在数据表中。


虽然通过加盐，实现了哈希长度扩展，但是攻击者通过提交密码和哈希值也可以破解攻击。服务器会把提交的密码和 salt 构成字符串，然后和提交的哈希值对比。如果系统不能提交哈希值，不会受到此类攻击。


显然，没有绝对安全的方法。但是不推荐使用密码加盐，而是 HMac 算法。它可以使用任意的 Hash 函数，例如 md5 => HmacMD5、sha1 => HmacSHA1。


下面是利用 Hmac 实现加密数据的函数：


```typescript
const crypto = require("crypto");
function encryptData(data, key, algorithm) {
    if (!crypto.getHashes().includes(algorithm)) {
        throw new Error("不支持此哈希函数");
    }
    const hmac = crypto.createHmac(algorithm, key);
    hmac.update(data);
    return hmac.digest("hex");
}
// output: 30267bcf2a476abaa9b9a87dd39a1f8d6906d1180451abdcb8145b384b9f76a5
console.log(encryptData("root", "7(23y*&745^%I", "sha256"));
```


## 对称加密(AES)与非对称加密解密(RSA)


有很多数据需要加密存储，并且需要解密后进行使用。这和前面不可逆的哈希函数不同。此类算法一共分为两类：

- 对称加密(AES)：加密和解密使用同一个密钥
- 非对称加密解密(RSA)：公钥加密，私钥解密

### 对称加密(AES)


查看 nodejs 支持的所有加密算法：


```typescript
crypto.getCiphers();
```


Nodejs 提供了 Cipher 类和 Decipher 类，分别用于加密和解密。两者都继承 Transfrom Stream，API 的使用方法和哈希函数的 API 使用方法类似。


下面是用 aes-256-cbc 算法对明文进行加密：


```typescript
const crypto = require("crypto");
const secret = crypto.randomBytes(32); // 密钥
const content = "hello world!"; // 要加密的明文
const cipher = crypto.createCipheriv(
    "aes-256-cbc",
    secret,
    Buffer.alloc(16, 0)
);
cipher.update(content, "utf8");
// 加密后的结果：e2a927165757acc609a89c093d8e3af5
console.log(cipher.final("hex"));
```


**注意**：在使用加密算法的时候，给定的密钥长度是有要求的，否则会爆出`this[kHandle].initiv(cipher, credential, iv, authTagLength); Error: Invalid key length...`的错误。以 aes-256-cbc 算法为例，需要 256 bits = 32 bytes 大小的密钥。同样地，AES 的 IV 也是有要求的，需要 128bits。（请参考“参考链接”部分）


使用 32 个连续`I`作为密钥，用 aes-256-cbc 加密后的结果是 a061e67f5643d948418fdb150745f24d。下面是逆向解密的过程：


```typescript
const secret = "I".repeat(32);
const decipher = crypto.createDecipheriv(
    "aes-256-cbc",
    secret,
    Buffer.alloc(16, 0)
);
decipher.update("a061e67f5643d948418fdb150745f24d", "hex");
console.log(decipher.final("utf8")); // 解密后的结果：hello world!
```


### 非对称加密解密(RSA)


借助 openssl 生成私钥和公钥：


```shell
# 生成私钥
openssl genrsa -out privatekey.pem 1024
# 生成公钥
openssl rsa -in privatekey.pem -pubout -out publickey.pem
```


对 `hello world!` 加密和解密的代码如下：


```typescript
const crypto = require("crypto");
const fs = require("fs");
const privateKey = fs.readFileSync("./privatekey.pem");
const publicKey = fs.readFileSync("./publickey.pem");
const content = "hello world!"; // 待加密的明文内容
// 公钥加密
const encodeData = crypto.publicEncrypt(publicKey, Buffer.from(content));
console.log(encodeData.toString("base64"));
// 私钥解密
const decodeData = crypto.privateDecrypt(privateKey, encodeData);
console.log(decodeData.toString("utf8"));
```


## 签名和验证算法


除了不可逆的哈希算法、数据加密算法，还有专门用于签名和验证的算法。这里也需要用 openssl 生成公钥和私钥。


代码示范如下：


```typescript
const crypto = require("crypto");
const fs = require("fs");
const assert = require("assert");
const privateKey = fs.readFileSync("./privatekey.pem");
const publicKey = fs.readFileSync("./publickey.pem");
const data = "传输的数据";
// 第一步：用私钥对传输的数据，生成对应的签名
const sign = crypto.createSign("sha256");
// 添加数据
sign.update(data, "utf8");
sign.end();
// 根据私钥，生成签名
const signature = sign.sign(privateKey, "hex");
// 第二步：借助公钥验证签名的准确性
const verify = crypto.createVerify("sha256");
verify.update(data, "utf8");
verify.end();
assert.ok(verify.verify(publicKey, signature, "hex"));
```


从前面这段代码可以看到，利用私钥进行加密，得到签名值；最后利用公钥进行验证。


## 总结


之前一直是一知半解，一些概念很模糊，经常混淆散列算法和加密算法。整理完这篇笔记，我才理清楚了常见的加密算法的功能和用途。


除此之外，crypto 模块还提供了其他算法工具，例如 ECDH 在区块链中有应用。这篇文章没有再记录，感兴趣的同学可以去查阅相关资料。


## 参考链接

- [NodeJS docs: crypto](http://nodejs.cn/api/crypto.html)
- [推荐：Node.js 加密算法库 Crypto](http://blog.fens.me/nodejs-crypto/)
- [推荐：什么是 hash？ - 腾讯技术工程的回答 - 知乎](https://www.zhihu.com/question/26762707/answer/890181997)
- [Wiki：散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)
- [Store and validate hashed password](http://aandds.com/blog/password-hashing.html)
- [Wiki: 彩虹表](https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8)
- [Nodejs 6.10.2 crypto AES Invalid key length](https://stackoverflow.com/questions/44502637/nodejs-6-10-2-crypto-aes-invalid-key-length)
- [Encrypting using AES-256, can I use 256 bits IV?](https://security.stackexchange.com/questions/90848/encrypting-using-aes-256-can-i-use-256-bits-iv)
- [Crypto 加密与解密](https://www.jianshu.com/p/e3187cf67559)

