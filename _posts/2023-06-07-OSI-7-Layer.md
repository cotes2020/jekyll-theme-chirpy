---
title: OSI-7 계층
author: littley
date: 2023-06-07 00:00:00 +0900
categories: [CS, Network]
tags: [Network]
toc: true
img_path: /assets/img/posts/OSI-7
---

## 1. Physical Layer
    
두 대의 컴퓨터가 통신하려면 0과 1만 주고받을 수 있으면 된다. 만약 전선 1개로 통신한다 하면, 1을 보낼 때는 +5V, 0을 보낼 때는 -5V의 전기를 보내면 된다. 하지만 실제로는 어렵다.  
![전자기파.png](Untitled.png)
파동이 들쭉날쭉하면 주파수 값이 달라지고, 전선 또한 모든 Hz를 통과시킬 수는 없기 때문에, 받는 입장에서는 생략된 주파수를 받게 된다. 게다가 컴퓨터 통신은 1과 0의 신호만 보내는데,  
![디지털전자기파.png](Untitled 1.png)  
이런 전기신호를 통과시킬 수 있는 전선은 없다. 따라서 1과 0을 전송하려면 아날로그 신호로 바꾸어서 전송**(인코딩)** 해야 하고, 받는 컴퓨터에서 아날로그 신호를 0과 1로 해석**(디코딩)** 해야 한다. 이렇게 물리적으로 연결된 두 대의 컴퓨터가 0과 1의 나열을 주고받을 수 있게 해주는 모듈이 **Physical Layer**이다. 각각 1계층 인코더와 1계층 디코더가 작동한다.

```cpp
Signal encode(Data data) { ... }
Data decode(Signal signal) { ... }
```

1계층 모듈은 PHY칩을 이용해서 하드웨어적으로 구현되어 있다.

> 💡 모든 컴퓨터를 서로 연결시킬 수 없기 때문에, 하나의 전선으로 여러 대의 컴퓨터가 통신하려면 모든 컴퓨터가 하나의 선을 공유해야 한다. 한 네트워크 내부적으로는 스위치를 사용하고, 서로 다른 두 네트워크 끼리는 라우터를 사용하여 통신한다.

![Untitled](Untitled 2.png) |![Untitled](Untitled 3.png)|

## 2. Data-link Layer
    
전 세계의 컴퓨터가 계층구조로 연결되어 있는 것이 인터넷이다. 1계층 만으로는 2개의 컴퓨터만 통신이 가능하고, 여러 대의 컴퓨터를 연결하려면 스위치를 사용해야 한다.  
![Untitled](Untitled 4.png)  
이런 상황에서 데이터를 구분하기 위해 송신자는 데이터의 앞 뒤에 특정한 비트열을 붙인다. 가령`0000`을 끝에,`1111`을 앞에 붙인다고 가정하면  
![Untitled](Untitled 5.png)  
이런 방식으로 데이터의 시작과 끝을 알 수 있다. **Data-link Layer**는 같은 네트워크에 있는 여러 컴퓨터가 데이터를 주고받기 위해 필요한 모듈이다. 하드웨어인 랜카드를 통해 구현되어 있다. 위에서 언급한 작업인 Framing이 2계층에 속하는 작업이다.

여기까지의 작업 흐름을 종합해보면  
![Untitled](Untitled 6.png)
	
## 3. Network Layer  
더 멀리 있는 컴퓨터에 데이터를 전송하고 싶으면 어떻게 할까?  
![Untitled](Untitled 7.png)  
데이터 앞에 보내고자 하는 **컴퓨터의 고유 주소(IP주소)**를 붙여서 보내면 된다. 그렇다면 A가 B의 주소를 어떻게 알 수 있을까? 우리가 보통 사용하는 도메인이 바로 보내고자 하는 곳의 IP 주소가 된다(자세한건 DNS 참조). 데이터와 주소가 합쳐진 것이 **패킷**이다.  
[Untitled](Untitled.mp4)  
[가]는 패킷을 열어서 내용물을 확인해 목적지가 자신의 네트워크에 속해 있는지 확인하고, 속해 있지 않으면 다시 포장한 뒤, [마]에 이를 전송한다. [마]는 이 데이터를 [가], [나], [바] 중 어디에 보낼지를 결정하기 위해 라우팅을 한다.  
자신과 연결되어 있는 모든 라우터에 신호를 보낸 다음, 이 신호가 다시 자신에게 돌아오면(즉 **루프**가 일어나면) 해당 신호는 차단시키고, 이 신호가 다시 돌아오지 않는 쪽이 목적지이므로 [바]로 보내야 한다는 사실을 알 수 있다.  
이 과정을 반복하면 데이터가 성공적으로 전송된다. 즉 **Network Layer**란 inter-network 속에서 어딘가에 있는 목적지 컴퓨터로 데이터를 전송하기 위해 IP주소를 이용해서 길을 찾고(Routing), 자신 다음의 라우터에게 데이터를 넘겨주는(forwarding) 활동을 하는 계층이다. 이 계층은 운영체제의 커널에 소프트웨어적으로 구현되어 있다.  

여기까지의 작업 흐름을 종합해보면  
![Untitled](Untitled 8.png)  

## 4. Transport Layer  
이제 인터넷 상의 모든 컴퓨터는 서로 통신할 수 있다. 컴퓨터는 고유한 **포트 번호**(서로 다른 프로세스를 구분하는 정수 값)를 가진 여러 프로세스를 실행시키고 있다.

한편, 송신자는 데이터를 보낼 때 데이터를 받을 수신자 컴퓨터에 있는 프로세스의 포트 번호를 붙여서 보낸다. 즉 전송자는 목적지 프로세스의 포트 번호 또한 알고 있어야 한다. (사실 네이버 또한 [www.naver.com](http://www.naver.com) 뒤에 :80이 생략된 형태다.)

포트 번호를 사용하여 최종 목적지인 수신자 컴퓨터의 프로세스까지 데이터가 도달하게 하는 모듈이 **Transport Layer**다. 이 기술 또한 운영체제의 커널에 소프트웨어적으로 구현되어 있다.  
![Untitled](Untitled 9.png)
    
## 5. Application Layer  
왜 갑자기 건너뛰는가? 실용적인 이유 때문에.
현대 인터넷이 TCP/IP 업데이트 모델을 따르고 있기 때문에 5, 6 계층은 거의 쓰이지 않는다.  
![Untitled](Untitled 10.png)

**TCP/IP 소켓 프로그래밍이란?**  
운영체제의 Transport Layer에서 제공하는 API를 활용해서 통신 가능한 프로그램을 만드는 것을 TCP/IP 소켓 프로그래밍 또는 네트워크 프로그래밍이라고 한다.  
이러한 소켓 프로그래밍만으로도 클라이언트와 서버 프로그램을 따로 만들어서 동작 시킬 수 있고, 누구나 자신만의 Application Layer 인코더와 디코더 즉 프로토콜을 만들 수 있다.  

---
## Reference
[[10분 테코톡] 🔮 히히의 OSI 7 Layer](https://www.youtube.com/watch?v=1pfTxp25MA8)