---
layout: post
title: "15-Go语言面向对象"
date: 2019-10-06 22:56:00.000000000 +09:00
categories: [Go]
tags: [Go, Go 面向对象]
---

## 面向对象基本概念

- 面向对象(Object Oriented,OO)是软件开发方法
- 面向对象是一种对现实世界抽象的理解，是计算机编程技术发展到一定阶段后的产物
- Object Oriented Programming-OOP ——面向对象编程

## 面向对象和面向过程区别

- 面向对象是相对面向过程而言
- 面向对象和面向过程都是一种思想
- 面向过程
  - 强调的是功能行为
  - 关注的是解决问题需要哪些步骤
- 回想下前面我们完成一个需求的步骤：
  - 首先搞清楚我们要做什么
  - 然后分析怎么做
  - 最后我用代码体现
  - 一步一步去实现，而具体的每一步都需要我们去实现和操作
- 在上面每一个具体步骤中我们都是参与者， 并且需要面对具体的每一个步骤和过程， 这就是面向过程最直接的体现

------

- 面向对象
  - 将功能封装进对象，强调具备了功能的对象
  - 关注的是解决问题需要哪些对象
- 当需求单一， 或者简单时， 我们一步一步去操作没问题， 并且效率也挺高。 可随着需求的更改， 功能的增加， 发现需要面对每一个步骤非常麻烦， 这时就开始思索， 能不能把这些步骤和功能再进行封装， 封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰多了， 用的时候， 找到对应的类就可以了， 这就是面向对象思想

------

- 示例
- 买电脑
  - 面向过程
    - 了解电脑
    - 了解自己的需求
    - 对比参数
    - 去电脑城
    - 砍价，付钱
    - 买回电脑
    - 被坑
  - 面向对象
    - 找班长
    - 描述需求
    - 班长把电脑买回来
    - 

------

- 吃饭
  - 面向过程
    - 去超市卖菜
    - 摘菜
    - 洗菜
    - 切菜
    - 炒菜
    - 盛菜
    - 吃
  - 面向对象
    - 去饭店
    - 点菜
    - 吃

------

- 洗衣服
  - 面向过程
    - 脱衣服
    - 放进盆里
    - 放洗衣液
    - 加水
    - 放衣服
    - 搓一搓
    - 清一清
    - 拧一拧
    - 晒起来
  - 面向对象
    - 脱衣服
    - 打开洗衣机
    - 丢进去
    - 一键洗衣烘干
  - 终极面向对象
    - 买电脑/吃饭/洗衣服
    - 找个对象
- 现实生活中我们是如何应用面相对象思想的
  - 包工头
  - 汽车坏了
  - 面试

## 面向对象的特点

- 是一种符合人们思考习惯的思想
- 可以将复杂的事情简单化
- 将程序员从执行者转换成了指挥者
- 完成需求时：
  - 先要去找具有所需的功能的对象来用
  - 如果该对象不存在，那么创建一个具有所需功能的对象
  - 这样简化开发并提高复用

## 类与对象的关系

- 面向对象的核心就是对象,那怎么创建对象?
  - 现实生活中可以根据模板创建对象,编程语言也一样,也必须先有一个模板,在这个模板中说清楚将来创建出来的对象有哪些`属性`和`行为`

+ Go语言中的类相当于图纸，用来描述一类事物。也就是说要想创建对象必须先有类
+ Go语言利用类来创建对象，对象是类的具体存在, 因此面向对象解决问题应该是先考虑需要设计哪些类，再利用类创建多少个对象

## 如何设计一个类

- 生活中描述事物无非就是描述事物的`属性`和`行为`。如：人有身高，体重等属性，有说话，打架等行为。

```
事物名称(类名):人(Person)
属性:身高(height)、年龄(age)
行为(功能):跑(run)、打架(fight)
```

- Go语言中用类来描述事物也是如此
  - 属性：对应类中的成员变量。
  - 行为：对应类中的成员方法。
- 定义类其实在定义类中的成员(成员变量和成员方法)
- 拥有相同或者类似`属性`（状态特征）和`行为`（能干什么事）的对象都可以抽像成为一个类

## 如何分析一个类

- 一般名词都是类(名词提炼法)
  - 飞机发射两颗炮弹摧毁了8辆装甲车

```
飞机
炮弹
装甲车
```

- 隔壁老王在公车上牵着一条叼着热狗的草泥马

```
老王
热狗
草泥马
```

## 如何定义一个类

- 类是用于描述事物的的属性和行为的, 而Go语言中的结构体正好可以用于描述事物的属性和行为
- 所以在Go语言中我们使用结构体来定义一个类型

```go
type Person struct {
    name string // 人的属性
    age int // 人的属性
}
// 人的行为
func (p Person)Say()  {
    fmt.Println("my name is", p.name, "my age is", p.age)
}
```

## 如何通过类创建一个对象

- 不过就是创建结构体的时候, 根据每个对象的特征赋值不同的属性罢了

```go
// 3.创建一个结构体变量
    p1 := Person{"hjw", 26}
    per.say()

    p2 := Person{"zs", 18}
    per.Say()

```

## 不同包中变量、函数、方法、类型公私有问题

- 在Go语言中通过首字母大小写来控制变量、函数、方法、类型的公私有
- 如果首字母小写, 那么代表私有, 仅在当前包中可以使用
- 如果首字母大写, 那么代表共有, 其它包中也可以使用

```go
package demo

import "fmt"

var num1 int = 123 // 当前包可用
var Num1 int = 123 // 其它包也可用

type person struct { // 当前包可用
    name string // 当前包可用
    age int // 当前包可用
}

type Student struct { // 其它包也可用
    Name string // 其它包也可用
    Age int // 其它包也可用
}

func test1()  { // 当前包可用
    fmt.Println("test1")
}
func Test2()  { // 其它包也可用
    fmt.Println("Test2")
}

func (p person)say()  { // 当前包可用
    fmt.Println(p.name, p.age)
}
func (s Student)Say()  { // 其它包也可用
    fmt.Println(s.Name, s.Age)
}
```

## 面向对象三大特性

- 封装性
  - 封装性就是隐藏实现细节，仅对外公开接口
  - 类是数据与功能的封装，数据就是成员变量，功能就是方法
- 为什么要封装?
  - 不封装的缺点：当一个类把自己的成员变量暴露给外部的时候,那么该类就失去对该成员变量的管理权，别人可以任意的修改你的成员变量
  - 封装就是将数据隐藏起来,只能用此类的方法才可以读取或者设置数据,不可被外部任意修改是面向对象设计本质(`将变化隔离`)。这样降低了数据被误用的可能 (`提高安全性`和`灵活性`)

```go
package model
import "fmt"
type Person struct { // 其它包也可用
    name string // 当前包可用
    age int // 当前包可用
}
func (p *person)SetAge(age int)  {
    // 安全校验
    if age < 0 {
        fmt.Println("年龄不能为负数")
    }
    p.age = age
}
```

```go
package main
import (
    "fmt"
    "main/model"
)
func main()  {
    // 报错, 因为name和age不是公开的
    //p := model.Person{"hjw", 18}

    // 方式一
    //p := model.Person{}
    //p.SetAge(18)
    //fmt.Println(p)

    // 方式二
    //p := new(model.Person)
    //p.SetAge(18)
    //fmt.Println(p)
}
```

- 封装原则
  - 将不需要对外提供的内容都隐藏起来,把属性都隐藏,提供公共的方法对其访问

------

- 继承性
  - Go语言认为虽然继承能够提升代码的复用性, 但是会让代码腐烂, 并增加代码的复杂度.
  - 所以go语言坚持了〃组合优于继承〃的原则, Go语言中所谓的继承其实是利用组合实现的(匿名结构体属性)
- 普通继承(组合)

```go
package main

import "fmt"

type Person struct {
    name string
    age int
}
type Student struct {
    Person // 学生继承了人的特性
    score int
}
type Teacher struct {
    Person // 老师继承了人的特性
    Title string
}
func main()  {
    s := Student{Person{"hjw", 18}, 99}
    //fmt.Println(s.Person.name)
    fmt.Println(s.name) // 两种方式都能访问
    //fmt.Println(s.Person.age)
    fmt.Println(s.age) // 两种方式都能访问
    fmt.Println(s.score)
}
```

- 继承结构中出现重名情况, 采用就近原则

```go
package main

import "fmt"

type Person struct {
    name string // 属性重名
    age int
}
type Student struct {
    Person
    name string // 属性重名
    score int
}
func main()  {
    s := Student{Person{"zs", 18}, "ls", 99}
    fmt.Println(s.Person.name) // zs
    fmt.Println(s.name) // ls
    //fmt.Println(s.Person.age)
    fmt.Println(s.age) // 两种方式都能访问
    fmt.Println(s.score)
}
```

- 多重继承

```go
package main

import "fmt"

type Object struct {
    life int
}
type Person struct {
    Object
    name string
    age int
}
type Student struct {
    Person
    score int
}
func main()  {
    s := Student{Person{Object{77}, "zs", 33}, 99}
    //fmt.Println(s.Person.Object.life)
    //fmt.Println(s.Person.life)
    fmt.Println(s.life) // 三种方式都可以
    //fmt.Println(s.Person.name)
    fmt.Println(s.name) // 两种方式都能访问
    //fmt.Println(s.Person.age)
    fmt.Println(s.age) // 两种方式都能访问
    fmt.Println(s.score)
}
```

```go
package main

import "fmt"

type Object struct {
    life int
}
type Person struct {
    name string
    age int
}
type Student struct {
    Object
    Person
    score int
}
func main()  {
    s := Student{Object{77}, Person{"zs", 33}, 99}
    //fmt.Println(s.Person.life)
    fmt.Println(s.life) // 两种方式都可以
    //fmt.Println(s.Person.name)
    fmt.Println(s.name) // 两种方式都能访问
    //fmt.Println(s.Person.age)
    fmt.Println(s.age) // 两种方式都能访问
    fmt.Println(s.score)
}
```

- 方法继承
  - 在Go语言中子类不仅仅能够继承父类的属性, 还能够继承父类的方法

```go
package main

import "fmt"
type Person struct {
    name string
    age int
}
// 父类方法
func (p Person)say()  {
    fmt.Println("name is ", p.name, "age is ", p.age)
}

type Student struct {
    Person
    score float32
} 

func main() {
    stu := Student{Person{"zs", 18}, 59.9}
    stu.say()
}
```

- 继承中的方法重写
  - 如果子类有和父类同名的方法, 那么我们称之为方法重写

```go
package main

import "fmt"
type Person struct {
    name string
    age int
}
// 父类方法
func (p Person)say()  {
    fmt.Println("name is ", p.name, "age is ", p.age)
}

type Student struct {
    Person
    score float32
}
// 子类方法
func (s Student)say()  {
    fmt.Println("name is ", s.name, "age is ", s.age, "score is ", s.score)
}
func main() {
    stu := Student{Person{"zs", 18}, 59.9}
    // 和属性一样, 访问时采用就近原则
    stu.say() 
    // 和属性一样, 方法同名时可以通过指定父类名称的方式, 访问父类方法
    stu.Person.say()
}
```

- 注意点:
  - 无论是属性继承还是方法继承, 都只能子类访问父类, 不能父类访问子类
- 多态性
  - 多态就是某一类事物的多种形态

```
猫: 猫-->动物
狗: 狗-->动物
男人 : 男人 -->人 -->高级动物
女人 : 女人 -->人 -->高级动物
```

- Go语言中的多态是采用接口来实现的

```go
package main

import "fmt"
// 1.定义接口
type Animal interface { 
    Eat()
}
type Dog struct {
    name string
    age int
}
// 2.实现接口方法
func (d Dog)Eat()  {
    fmt.Println(d.name, "正在吃东西")
}

type Cat struct {
    name string
    age int
}
// 2.实现接口方法
func (c Cat)Eat()  {
    fmt.Println(c.name, "正在吃东西")
}
// 3.对象特有方法
func (c Cat)Special()  {
    fmt.Println(c.name, "特有方法")
}

func main()  {
    // 1.利用接口类型保存实现了所有接口方法的对象
    var a Animal
    a = Dog{"旺财", 18}
    // 2.利用接口类型调用对象中实现的方法
    a.Eat()
    a = Cat{"喵喵", 18}
    a.Eat()
    // 3.利用接口类型调用对象特有的方法
    //a.Special() // 接口类型只能调用接口中声明的方法, 不能调用对象特有方法
    if cat, ok := a.(Cat); ok{
        cat.Special() // 只有对象本身才能调用对象的特有方法
    }
}
```

- 多态优点
  - 多态的主要好处就是简化了编程接口。它允许在类和类之间重用一些习惯性的命名,而不用为每一个新的方法命名一个新名字。这样,编程接口就是一些抽象的行为的集合,从而和实现接口的类的区分开来
  - 多态也使得代码可以分散在不同的对象中而不用试图在一个方法中考虑到所有可能的对象。 这样使得您的代码扩展性和复用性更好一些。当一个新的情景出现时,您无须对现有的代码进行改动,而只需要增加一个新的类和新的同名方法