---
title: "各类模块规范以及AMD/UMD原理"
date: 2023-02-10
permalink: /2023-02-10-modules/
categories: ["B源码精读", "Others"]
tags: ["模块设计"]
---

## 几种模块化规范

- CommonJS：Nodejs，运行在服务端环境
- CMD（Common Module Definition - 通用模块定义）：主要通过 `sea.js` 流行起来，是国内大佬的作品。

	写法模仿CommonJS规范，不过是运行在浏览器环境

- AMD（Asynchronous Module Definition - 异步模块定义）：采用异步加载，运行在浏览器环境，使用广泛。常用的库是 `require.js`
- UMD（Universal Module Definition - 通用模块定义）：该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题。
**在开发中，产物模块规范变成umd后，可以在commonjs、AMD、CMD等多种环境下使用，应用广泛，功能强大，是线上产物常用规范。**
- ESM（ES Modules）：ES6 规范，目前也可以运行在高版本的浏览器和Nodejs中

### 参考文章


[bookmark](https://zhuanlan.zhihu.com/p/108217164)


## IIFE


CMD、AMD、UMD的实现，本质上就是利用函数立即执行表达式（immediately invoked function expression），在不同环境下的全局对象上，挂入模块。


## Sea.js 实现原理（不推荐使用）


### 魔法在哪里？


```javascript
define('a', function (require,exports,modules){
	var b = require('b')
})
```


和 `require.js` 显式声明依赖不一样，写法类似 CommonJS 规范。


由于没有去提前声明/配置（回调函数只有定义，没有运行），那么如何在「加载期」知道依赖哪个模块呢？


### 实现原理


核心是利用 `Function.toString` 方法，拿到「函数的字符串定义」。


「加载期」：

- 通过回调函数的Function.toString函数，使用[正则表达式](https://www.zhihu.com/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A32484869%7D)来捕捉内部的require字段，找到require('jquery')内部依赖的模块jquery
- 根据配置文件，找到jquery的js文件的实际路径；如果有多个依赖，也会根据依赖树确定先后顺序
- 在dom中插入script标签，载入模块指定的js，绑定加载完成的事件，使得加载完成后将js文件绑定到require模块指定的id（这里就是jquery这个字符串）上

「运行期」：

- 回调函数内部依赖的js全部加载（暂不调用）完后，调用回调函数
- 当回调[函数调用](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A32484869%7D)require('jquery')，即执行绑定在'jquery'这个id上的js文件，即刻执行，并将返回值传给var b

### 参考文章


[bookmark](https://www.zhihu.com/question/20342350/answer/32484869)


[bookmark](https://segmentfault.com/a/1190000000471722)


## UMD


### 魔法在哪里？


支持AMD、CMD规范，也支持原生的直接在window上定义的做法，还支持CommonJS。


### 实现原理


利用 IIFE 的写法，内部区别处理即可。


下面是考虑到「有前置依赖」的UMD的实现思路：


```javascript
(function(root, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        console.log('是commonjs模块规范，nodejs环境')
        var depModule = require('./umd-module-depended')
        module.exports = factory(depModule);
    } else if (typeof define === 'function' && define.amd) {
        console.log('是AMD模块规范，如require.js')
        define(['depModule'], factory)
    } else if (typeof define === 'function' && define.cmd) {
        console.log('是CMD模块规范，如sea.js')
        define(function(require, exports, module) {
            var depModule = require('depModule')
            module.exports = factory(depModule)
        })
    } else {
        console.log('没有模块环境，直接挂载在全局对象上')
        root.umdModule = factory(root.depModule);
    }
}(this, function(depModule) {
    console.log('我调用了依赖模块', depModule)
		// ...省略了一些代码，去代码仓库看吧
    return {
        name: '我自己是一个umd模块'
    }
}))
```


在线案例演示了在sea.js上下文中，引入了一个UMD规范的文件，其可以被正常加载：


[bookmark](https://cumt-robin.github.io/umd-learning/umd-dep-used-by-seajs.html)


### 参考文档


[bookmark](https://juejin.cn/post/6844903927104667662)


## 配套工具


### NPM 入口


在monorepo / SDK开发中，经常会对不同的运行环境，输出不同的产物。这些产物的「入口文件」在 package.json 中可以声明，如下所示：


![Untitled.png](https://raw.githubusercontent.com/dongyuanxin/static/main/blog/imgs/2023-02-10-modules/09028bb5b943df752c752c76a305223d.png)


目前支持3种字段：

- browser：在 browser 下的入口文件
- module：在 browser & node 下的入口文件，符合 ESM 规范
- main：在 browser & node 下的入口文件

同时声明这3个字段时，在不同的环境下，解析优先级不一样：

- 在非browser下：module > main
- 在browser下：browser > module > main

### Webpack

- 环境：可以通过[ ](https://webpack.js.org/configuration/target/)[**`target`**](https://webpack.js.org/configuration/target/)[ **字段**](https://webpack.js.org/configuration/target/)来声明产物运行环境。 每个环境，解析依赖包的入口文件时，优先级都不同。
- 解析顺序：通过 [**`mainFields`**](https://webpack.docschina.org/configuration/resolve/#resolvemainfields)[ **字段**](https://webpack.docschina.org/configuration/resolve/#resolvemainfields)可以自定义解析顺序，比如 `[main, module]`

### 参考文档


[bookmark](https://github.com/SunshowerC/blog/issues/8#browser-vs-module-vs-main)


## 用法示例


下面文章都挺好的，没必要重复拷贝，直接看原文吧。


### AMD & require.js


[bookmark](https://www.ruanyifeng.com/blog/2012/10/javascript_module.html)


[bookmark](https://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)


[bookmark](https://www.ruanyifeng.com/blog/2012/11/require_js.html)


[bookmark](https://blog.csdn.net/weixin_41196185/article/details/81237243?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167575493016800222819176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167575493016800222819176&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-81237243-null-null.blog_rank_default&utm_term=%E6%A8%A1%E5%9D%97%E5%8C%96&spm=1018.2226.3001.4450)


### NodeJS

[bookmark](https://blog.csdn.net/weixin_41196185/article/details/81211394?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167575493016800222819176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167575493016800222819176&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-81211394-null-null.blog_rank_default&utm_term=%E6%A8%A1%E5%9D%97%E5%8C%96&spm=1018.2226.3001.4450)
