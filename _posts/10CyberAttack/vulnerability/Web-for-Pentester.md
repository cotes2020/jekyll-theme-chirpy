

# Web-for-Pentester

[toc]

---

[Web for Pentester](https://pentesterlab.com/exercises/web_for_pentester/course)

# Web technologies
Most web applications rely on 3 components:
1. The client: a web browser in most cases.
2. The web server that will receive requests from the client. An application server can be involved to process the requests; in that case the web server will just forward the requests to the application server.
3. The storage backend to retrieve and save information, most commonly a database.

Client side technologies
- Most client side technologies:
  - HTML, JavaScript, Flash... through their browsers (Chromium, Firefox, Internet Explorer, Safari...).
- However, web applications' clients can also be a thick client connecting to a web service or just a script.

Server side technologies
- The server side can be divided into more sub-categories:
  - Web servers
    - Apache, lighttpd, Nginx, IIS...
  - Application servers
    - Tomcat, Jboss, Oracle Application server...
  - The programming language used:
    - PHP, Java, Ruby, Python, ASP, C#, ...
    - This programming language can also be used as part of a framework like Ruby-on-Rails, .Net MVC, Django.

Storage backend
- The storage backend can be located on the same server as the web server or on a different one. This can explain weird behaviour during the exploitation of some vulnerabilities.
- A few examples of backends are:
  - Simple files.
  - Relational databases
    - Mysql, Oracle, SQL Server, PostgreSQL.
  - Other databases
    - MongoDB, CouchDB.
  - Directories
    - openLDAP or Active Directory.

An application can use more than one storage backend. For example, some applications use LDAP to store users and their credentials and use Oracle to store information.

---

# The HTTP protocol
HTTP is the base of the web, it's really important to have a deep understanding of this protocol in order to perform web security testing. Knowing and understanding HTTP specificities will often allow you to find vulnerabilities and exploit them.

## A Client-server dialog
- HTTP is a dialog between one client and one server.
- The client, the browser, sends a request to the server, and then the server responds to this request.
- HTTP has the advantages of being a text protocol and therefore really easy to read, understand and learn for a human being.
- By default, most web servers are available on port TCP/80.
  - When your browser connects to a URL https://pentesterlab.com/, it d a TCP connection to the port 80 of the IP corresponding to the name pentesterlab.com.

The most common request occurs when a browser asks the server for content.
- The browser sends a request composed of the following elements:
  - An `HTTP method` that will allow the server to understand what kind of operation the browser wants to perform.
  - A `resource` that corresponds to what the client is trying to access on the server.
  - A `version` that will allow the server to know what version of HTTP the browser is talking.
  - Optionally, various headers giving more information to the server like the browser's name and version, the preferred language of the user (like in English, German, French,...), ...
  - Depending on the HTTP method used, a `request body`.

```
As an example

request to the URL https://vulnerable/index.php will correspond to the following HTTP request:

GET /index.php HTTP/1.1
Host: vulnerable
User-Agent: Mozilla Firefox

```

---

## Requests

---

### Methods

Many HTTP methods exist:
- The `GET` method:
  - to request for content, it's the most common request sent by browsers;
- The `POST` method:
  - POST is used to send a larger amount of data;
  - used by most forms and also for file upload.
- The `HEAD` method:
  - the HEAD method is very similar to the GET request,
  - the only difference is in the response provided by the server,
  - the response will only contain the headers and no body.
  - `HEAD` is massively used by web spiders to check if a web page has been updated without downloading the full page content.
  - many other HTTP methods:
    - PUT, DELETE, PATCH, TRACE, OPTIONS, CONNECT...

---

### Parameters

```bash
# When a client accesses the following page https://vulnerable/article.php?id=1&name=2
# the following request is sent to the web server

GET /article.php?id=1&name=2 HTTP/1.1
Host: vulnerable
User-Agent: Mozilla Firefox

# POST requests are really similar
# but instead the parameters are sent in the request body.
```

1. HTML code on server

```bash
# This HTML code

        <html>
            [...]
        <body>
            <form action="/login.php" method="POST">
                Username: <input type="text" name="username"/> <br/>
                Password: <input type="password" name="password"/> <br/>
                <input type="submit" value="Submit">
            </form>
        </body>
        </html>


# This HTML code corresponds to the browswer login form:
# - Once the form is filled with the following values:

        username equals 'admin',
        password equals 'Password123'.
```

2. **Client request** sent to the server:

```bash
# After it gets submitted, the following request is sent to the server:

        POST /login.php HTTP/1.1
        Host: vulnerable
        User-Agent: Mozilla Firefox
        Content-Length: 35
        username=admin&password=Password123


# if the method GET was used in the <form tag,
# the values provided will be sent as part of the URL and look like:

        GET /login.php?username=admin&password=Password123 HTTP/1.1
        Host: vulnerable
        User-Agent: Mozilla Firefox

# If the form tag contains an attribute enctype="multipart/form-data",
# the request sent will be different:

        POST /upload/example1.php HTTP/1.1
        Host: vulnerable
        Content-Length: 305
        User-Agent: Mozilla/5.0 [...] AppleWebKit

        Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryfLW6oGspQZKVxZjA
        ------WebKitFormBoundaryfLW6oGspQZKVxZjA
        Content-Disposition: form-data; name="image"; filename="myfile.html"
        Content-Type: text/html
        My file
        ------WebKitFormBoundaryfLW6oGspQZKVxZjA
        Content-Disposition: form-data; name="send"
        Send file
        ------WebKitFormBoundaryfLW6oGspQZKVxZjA--

The `Content-type` header: `Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryfLW6oGspQZKVxZjA`.
- The `"Webkit"` comes from a Webkit-based browser;
- other browsers will use a long random string instead.
- This string is repeated for every part of the multipart information.
- The last part contains the string followed by `--`.
```

3. upload a file

In the `multi-part` section dedicated to the file, you will see the following information:

```
The file name: myfile.html.
The parameter name: image.
The file content type: text/html.
The file content: My file.
```

It's also possible to send parameters as an array (or hash depending on the parsing performed on the server side).
- for example
  - use: `/index.php?id[1]=0` to encode an array containing the value 0.


This method of encoding is often used by frameworks to **perform automatic request to object mapping**.
- For example,
- request: `user[name]=louis&user[group]=1 `
  - will be mapped to an `object User` with the attribute `name` equal to louis and the attribute `group` mapped to 1.
- This automatic mapping can sometimes be exploited using attacks named mass-assignment.
  - By sending additional parameters, if the application does not protect against it,
  - change attributes in the receiving object.
    - add user[admin]=1 to the request
    - gets administrator privileges.

---

### HTTP Headers

---

## Responses
When you send a request, the server will respond back with an HTTP response.

```bash
HTTP/1.1 200 OK
Date: Sun, 03 Mar 2013 10:56:20 GMT
Server: Apache/2.2.16 (Debian)
X-Powered-By: PHP/5.3.3-7+squeeze14
Content-Length: 6988
Content-Type: text/html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>PentesterLab Â» Web for Pentester</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Web For Pentester">
    <meta name="author" content="Louis Nyffenegger louis@pentesterlab.com">
[...]
```

---

# Listening to HTTP traffic
There are 3 ways to listen to HTTP traffic:
1. listening to the network directly with tools like Wireshark or tcpdump.
2. In the browser; most browsers have an extension allowing a user to see what traffic is transmitted and received.
3. set up a proxy between the browser and server.

---

## Generating HTTP traffic
Generating HTTP traffic can be performed in different ways:
1. use a tool like telnet or netcat and type your request.
2. use a programming language to write and read traffic from a socket, and communicate with the server, most languages have an HTTP library allowing a programmer to easily build and send requests and get the corresponding responses.
3. generate an HTTP request by browser.

```bash
# 1. Using telnet (or netcat) you can quickly send HTTP requests:
# do the same thing using netcat:

$ telnet vulnerable 80
GET / HTTP/1.1
Host: vulnerable
[...]


$ echo "GET / HTTP/1.1\r\nHost: vulnerable\r\n\r\n" | nc vulnerable 80
[...]
```

---

## Data encoding

### URL encoding
The simplest encoding consists of using % followed by the hexadecimal value of the character.

some characters are used in HTTP to distinguish between:
Each request's lines: \r\n.
Each part of the HTTP request (like between the method and the URI): space .
The path and the parameters: ?.
Each parameter: &;
A parameter name and the corresponding value: =.

However, for most attacks these characters are needed, in order to ensure a character is understood as a value and not as part of a request's delimiter; it needs to be encoded.

Character | URL encoded value
---|---
\r | %0d
\n | %0a
(space) | %20 or `+`
? | %3f
& | %26
= | %3d
; | %3b
`#` | %23
% | %25


### Double encoding
Sometimes, the system being tested can also decode the provided value, twice.
- For example, the web server can do a first decoding and the application a second one.
- In this case, you will need to double encode the special characters you want to send.

To do so, you just need to re-encode the encoded value.
- For example
  - to double-encoded an equal sign `=`
  - `encode` it as a %3d
  - and then re-`encode` it: %253d.
  - Once receiving %253d,
  - the web server `decode` it as %3d
  - and the web application `decode` %3d again as `=`.


### HTML encoding
As with URL encoding, some characters in HTML have a specific semantic and should therefore be encoded if they need to be used without their semantics' implication.

Character | HTML encoded value
---|---
`>` | `&gt;`
`<` | `&lt;`
`&` | `&amp;`
`"` | `&quote;`
`'` | `&#39;`

Any character can also be encoded using `Decimal value` or `Hexadecimal value`
- for example
  - `=` can be encoded
  - `Decimal value`as `&#61;`.
  - `Hexadecimal value` as `&#x3d;`.


---

## Cookies and sessions

1. Cookies (and indirectly sessions) are used to keep information between two HTTP requests.
2. keep information as part of the URL, but this can quickly get ugly

Cookies are initially sent by the server using an HTTP header: `Set-Cookie`.
- Once this header is received, the browser will automatically send the cookie back to the server, in all subsequent requests sent to this server, using a Cookie header.

The `Set-Cookie` header contains many optional fields:
1. An `expiration date`: to tell the browser when it should delete the cookie.
2. A `Domain`: to tell the browser what sub-domain or hostname the cookie should be sent to.
3. A `Path`: to tell the browser which path the cookies should be sent.
4. `Security flags`.


By default, the `Path` and `Domain` are mostly used to `increase or restrict the availability of a given cookie` for the application `within the same domain or within the same server`.
   - access other companies' information by sending the cookies received by `companyA.domain.com` to `companyB.domain.com`
   - The cookie scope was limited to each sub-domain so it didn't get detected earlier.

Cookies can have two security related flags:
1. `httpOnly`:
   - to **prevent the access to the cookies by JavaScript code**.
   - prevents trivial exploitation of XSS
   - by **limiting direct access to cookies** using `document.cookie` in JavaScript.
2. `secure`:
   - to **prevent the browser from sending the cookies over unencrypted communications**.
   - This is mostly used to limit the risk of someone getting his cookie stolen, when browsing a web site without a secure connection.

`Sessions` are mechanisms that use cookies as a transport medium.
- The **main problem with cookies**: users can intercept and tamper with them.
- To prevent this, developers started using sessions.
  - The cookie sent back to the user contains a `session identifier (session id)`. When the user sends the cookie back in the next requests, the application uses this session identifier to access information stored locally.
  - This information can be stored in a file, in a database or in memory.
  - Some sessions' mechanisms also encrypt the data for security reasons.

`Rack::Session::Cookie` is used by default in Rack based applications (most of Ruby applications use Rack).
- This provides a different session mechanism.
- The information is sent back to users, but is signed with a secret.
- This way, the users cannot tamper with the information in the session (but they can still access it, once they decode it).

By default, in PHP, the sessions are saved using one file per session
- stored unencrypted (on Debian in /var/lib/php5/).
- can go and read other peoples' session information.
- for example
  - session id (the value sent back in the cookie value) is `o8d7lr4p16d9gec7ofkdbnhm93`,
  - will see a file named `sess_o8d7lr4p16d9gec7ofkdbnhm93` which contains the information in the session:

```bash
# cat /var/lib/php5/sess_o8d7lr4p16d9gec7ofkdbnhm93
pentesterlab|s:12:"pentesterlab";
```

A web server can share sessions between multiple applications. It's always interesting to check if a valid session for one application can give you access to another application.


---

## HTTP authentication
HTTP provides mechanisms to authenticate users.

three methods available as part of the protocol:
1. `Basic Authentication`:
   - the username and password are encoded using base64 and sent using an Authorization header:
   - `Authorization: basic YWRtaW46YWRtaW4K`.
2. `Digest Authentication`:
   - the server sends a challenge (unique information to be used),
   - the client responds to this challenge (hash information including the password provided by the user).
   - This mechanism prevents the password from being sent unencrypted to the server.
3. `NTLM authentication`:
   - mostly used in the Microsoft world and is quite similar to Digest.

---

## Web services
Web services are mostly a simple way to call remote methods using HTTP. It's basically a fancy way to send calls to the server and get a response back. The information sent can be:
- Sent as with any other HTTP requests for REST.
- Sent using XML messages for SOAP.
- Sent using JSON-based message.

The remote method called can be retrieved by the server:
- Based on the URL.
- Based on the HTTP header (SOAPAction for example).
- Based on the message content.

Testing web services is really similar to testing traditional web applications, aside from the fact that your browser will probably not (out of the box) be able to talk to the server-side. But once you have examples of requests, you can easily use a scripting language or any tool allowing you to send HTTP request to fuzz and attack the server-side code.

---

# Web application security

---

## Client Side Security
A common misconception of developers is to perform security checks on the client side, for example in JavaScript.

![js_nok3s.svg](https://i.imgur.com/P0Hrzxy.png)
![js_nok4s.svg](https://i.imgur.com/gWauhRR.png)

----

## Bypassing Client Side Checks
To bypass client side checks, you need to setup a proxy like Burp Suite.
- have the proxy running, tell browser to send the requests through this proxy (by changing its configuration or environment variables depending on your browser and operating system).
- You will then see the requests sent by your browser and will be able to intercept and tamper with them.

![proxy3s.svg](https://i.imgur.com/AiD7Mjy.png)

By using the correct value in the browser, the form gets submitted.
- However, the proxy is then used to modify the value and start attacking the web application:

![js_proxy2s.svg](https://i.imgur.com/C3eG0wx.png)

---

## Server side
Applications' security should be performed on the server side.
- All information received should not be trusted;
- data itself or data format should be considered as malicious.
- Don't expect a parameter to be a string; it can be a hash or an array.
- Don't expect a parameter to be an integer; it can be a string.
- Even the hostname of the current server (provided by the Host header) can be malicious.
- Don't trust anything and make sure you double check everything.
- It's likely that someone will find out about something, if you build a weak application.
- Don't expect people to not find out about something;
- if you build something weak it's likely that someone will find out.

---

## testing

---

### Fingerprinting

#### Fingerprinting the web server
consists of trying to retrieve as much information as possible about it:
- Name and version of the server.
- Is an application server used in the backend?
- Database backend, is the database on the same host.
- Usage of a reverse proxy.
- Load balancing.
- Programming language used.

```bash
# Retrieving the server name and version can be easily done by inspecting the HTTP headers:
$ telnet vulnerable 80
GET / HTTP/1.1
Host: vulnerable

HTTP/1.1 200 OK
Date: Sun, 03 Mar 2013 10:56:20 GMT
Server: Apache/2.2.16 (Debian)
X-Powered-By: PHP/5.3.3-7+squeeze14
Content-Length: 6988
Content-Type: text/html


# You can also use a bad Host header (or just the IP) to get the default virtual-host and get more information:
$ telnet vulnerable 80
GET / HTTP/1.1
Host: thisisabadvalue
```

---

#### Browsing the web site

track of any interesting functionalities found:
- Upload and download functionalities.
- Authentication forms and links: login, logout, password recovery functions.
- Administration section.
- Data entry points: "Leave a comment", "Contact us" forms.

check the source of the web page and search for HTML comments.
- Comments often provide interesting information about the web site.

The file extension used by the web site will provide you more information about which technology is being used:
- `.php file`, the application is written in PHP;
- `.jsp` or `.do files`, the application is written in Java;
- Someone can obviously write a Java application with `.php` extensions or a PHP application with `.do` extensions but it's really unlikely.


It's also possible to fingerprint the website by looking at the way the actions are mapped to URLs. For example, in Ruby-On-Rails, developers can use scaffolding to automatically generate code to manage the `views (HTML code)`, the `model (storage logic)` and the `controller (business logic)` for a given object. This will generate a URL mapping in which:

```bash
/objects/ will give you a list of all the objects;
/objects/new will give you the page to create a new object;
/objects/12 will give you the object with the id 12;
/objects/12/edit will give you the page to modify the object with the id 12;
...
```

---

#### Check for favicon.ico
The `favicon.ico` is this little picture you can find in your browser URL bar when you visit a web site:
- This picture can be used as a fingerprinting element since most developers or system administrators don't change it and most applications or servers provide their own.
- For example, the favicon below is used by Drupal.
- favicon.ico drupal

---

#### Check the robots.txt file
Another common file deployed with applications is the robots.txt.
- Some PHP-based applications make heavy use of robots.txt, to prevent search engines from indexing some parts of the application.
- They are a really good source of information, and can be used to map interesting parts of the application and to find out what framework or application is used to build the website.

For example, the following robots.txt is used by the CMS Joomla:

```bash
# If the Joomla site is installed within a folder such as at
# e.g. www.example.com/joomla/ the robots.txt file MUST be
# moved to the site root at e.g. www.example.com/robots.txt
# AND the joomla folder name MUST be prefixed to the disallowed
# path, e.g. the Disallow rule for the /administrator/ folder
# MUST be changed to read Disallow: /joomla/administrator/
#
# For more information about the robots.txt standard, see:
# https://www.robotstxt.org/orig.html
#
# For syntax checking, see:
# https://tool.motoricerca.info/robots-checker.phtml

User-agent: *
Disallow: /administrator/
Disallow: /cache/
Disallow: /cli/
Disallow: /components/
Disallow: /images/
Disallow: /includes/
Disallow: /installation/
Disallow: /language/
Disallow: /libraries/
Disallow: /logs/
Disallow: /media/
Disallow: /modules/
Disallow: /plugins/
Disallow: /templates/
Disallow: /tmp/
```

what you should check.
- If a website does not want something to be indexed it's probably because it's interesting security-wise.


#### Searching for directories and pages
search for pages or directories that are not directly available through a link.
- use a list of file names and check if these names exist on the remote server.


##### Directory/Pages busting
The tool [Wfuzz](https://www.edge-security.com/wfuzz.php)
- detect directories and pages on the web server
- using wordlists of common resource names.

```bash
# to detect remote files and directories:
$ python wfuzz.py -c -z file,wordlist/general/common.txt --hc 404 https://vulnerable/FUZZ
```

You can do a lot with Wfuzz:
1. Filter based on the error code.
2. Only search for files with a given extension: https://vulnerable/FUZZ.php.
3. Brute force credentials.


##### Finding administration pages
Most administration pages are well known URLs, and can be found using a directory buster. However it's always really handy to keep a list of administration pages per technology/server. You can also check the product/project documentation to get this information.

Among your list of administration pages, keep information about default credentials that work with them.

---

### Generating errors

1. Generating 404 errors give a lot of information about the backend hosting the web application.
    - to generate the error, put a random string in the URL you request

Tomcat:

![tomcat404](https://i.imgur.com/8jXhm7r.png)

Ruby-on-Rails:

![rails404](https://i.imgur.com/QqHMivZ.png)


2. adding some special characters, like a NULL byte (%00), a single quote (%27) or a double quote (%22) you are likely to generate errors.

3. remove a value from the HTTP request.

    - example:
    - test with a PHP applications is to replace `/index.php?name=hacker` with `/index.php?name[]=hacker`.

![php-error](https://i.imgur.com/EzOUmMq.png)



---


# Cross-Site Scripting (XSS)


```js

// Example 1
<script>alert(1);</script>





```


.
