---
title: RxJava(1) - 개요
author: Bean
date: 2022-01-10 20:55:00 +0800
categories: [Mobile frontend, Android]
tags: [RxJava]
layout: post
current: post
class: post-template
subclass: 'post'
navigation: True
cover:  assets/img/post_images/rxjava_cover.jpeg
---


Catty 서비스를 개발하면서 그동안 미뤄뒀던 RxJava에 대한 공부와 함께 서비스에 코드를 적용해보았다.

Catty 서비스의 경우 서비스를 통해서 촬영한 스크린샷과 사진을 구글 드라브에 바로 연동을 하도록 되어 있다. 이 때 구글 드라이브에 ‘Catty’라는 루트 폴더를 생성하고, 그 루트 폴더 내에 각각 스크린샷, 사진 저장용 폴더를 생성한 후 그 속에 사진을 저장하도록 구조가 잡혀있었다.

만약 구글드라이브 내에 한 번이라도 스크린샷, 사진 용 폴더가 생성이 되었다면 폴더 아이디를 통해 추가 폴더 생성 과정없이 바로 자료를 저장하지만, 미리 생성되어 있던 폴더가 없거나 저장과정에서 어떤 오류가 발생하면 루트 폴더 생성 → 스크린샷/사진 폴더 생성 → 자료 저장의 과정을 밟아야 했고 이 과정에서 콜백이 증가하면서 콜백 복잡도가 증가(callback hell)하게 되었다.

그래서 우선적으로 RxJava를 이용하여 이런 부분을 리팩토링 하고 점차 다른 부분도 RxJava를 적용해 나가보았다.
\
&nbsp;
## RxJava란
***

RxJava는 자바(Java)에서 리액티브 프로그래밍을 구현하는 데 사용하는 라이브러리이다. 이벤트 처리와 같은 비동기 처리에 최적화되었으며, 2.0 버전부터 Reactive Streams 사양을 구현한다.

RxJava는 넷플릭스(Netflix)의 기술블로그에서 처음 소개되었다. **그 당시 넷플릭스는 REST 기반의 서비스 API 호출 횟수와 서비스의 전반적인 성능을 개선하는 프로젝트를 진행했고, 그결과 .NET 환경의 리액티브 확장 라이브러리(Rx)를 JVM에 포팅하여 RxJava를 만들었다.** 넷플릭스에서 RxJava를 만들게된 핵심적인 이유를 다음과 같이 밝혔다.

* 동시성을 적극적으로 끌어안을 필요가 있다(Embrace Concurrency)

    첫번째 이유의 원인은 자바가 동시성 처리를 하는데 번거로움이 있기 때문이다. 이를 해결하려고 넷플릭스는 클라이언트의 요청을 처리하는 서비스 계층(service layer)에서 동시성을 적극적으로 끌어안았다. **클라이언트의 요청을 처리할때 다수의 비동기 실행 흐름(스레드 등)을 생성하고 그것의 결과를 취합하여 최종 리턴하는 방식으로 내부 로직을 변경했다.**
* 자바 Future를 조합하기 어렵다는 점을 해결해야 한다(Java Futures are Expensive to Compose)

    두번째 이유의 원인은 2013년 당시 자바8에서 제공하는 CompletableFuture 같은 클래스가 제공되지 않았기 때문이다. 그래서 비동기 흐름을 조합할 방법이 거의없었다. **RxJava에서는 이를 해결하려고 비동기 흐름을 조합(compose)할 수 있는 방법을 제공한다. RxJava에서는 조합하는 실행 단위를 리액티브 연산자(Operators)라고 한다.**
* 콜백 방식의 문제점을 개선해야 한다(Callbacks Have Their Own Problems)

    세번째 이유의 원인은 콜백이 콜백을 부르는 콜백 지옥(Callback Hell) 상황이 코드의 가독성을 떨어뜨리고 문제 발생시 디버깅을 어렵게 만들기 때문이다. **비동기 방식으로 동작하는 가장 대표적인 프로그래밍 패턴은 콜백이다. 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계해 이를 해결했다.** 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계해 이를 해결했다.

리액티브 프로그래밍은 비동기 연산을 필터링, 변환, 조합해 위 세가지 핵심이유를 해결할 수 있다. 따라서 RxJava는 Observable과 같은 데이터 소스와 map(), filter(), reduce()와 같은 리액티브 연산자를 제공한다.

RxJava는 2016년 10월에 완전히 새로 작성한 RxJava 2.0을 발표했다. RxJava 2.0은 RxJava 1.x를 Reactive-Streams 스펙 기반으로 새롭게 개선한 것이므로 공통점도 많고 차이점도 많다.

Reactive-Stream 스펙은 자바8에 도입된 Stream API와 Observable 기반의 리액티브 프로그래밍을 포괄하는 표준 스펙으로 자바 9에 도입되었다.
\
&nbsp;
\
&nbsp;
## 리액티브 프로그래밍이란
***

앞서 RxJava는 자바에서 리액티브 프로그래밍을 구현하는 데 사용하는 라이브러리라고 하였다. 그런데 리액티브 프로그래밍이 정확히 뭘까?
정의상으로 리액티브 프로그래밍은 **변화의 전파**와 **데이터 흐름**과 관련된 **선언적 프로그래밍** 패러다임이다.

각각을 조금 뜯어 살펴보면,

* **변화의 전파와 데이터 흐름** : 데이터가 변경 될 때 마다 이벤트를 발생시켜서 데이터를 계속적으로 전달한다.
* **선언적 프로그래밍** : 실행할 동작을 구체적으로 명시하는 명령형 프로그램이과 달리 선언형 프로그래밍은 단순히 목표를 선언한다.

예를 들어, GPS 위치 정보가 변경될 때의 데이터 전송 흐름을 상상해보자. 이동해서 위치 정보가 변경될 때마다 데이터를 전송하고 이동을 멈추면 데이터 전송도 중지하는 것처럼 생성되는 데이터를 한 번에 보내지 않고 각각의 데이터가 생성될 때마다 순서대로 보낸다. 이런 데이터 흐름을 데이터 스트림(data stream)이라고 한다. 이 것은 이미 생성된 데이터 집합인 리스트(list) 같은 컬렉션(collection)과는 다르게 앞으로 발생할 가능성이 있는 데이터까지도 포함하는 데이터 집합체이다.

좀 더 쉽게 이해하기 위해 명령형 프로그래밍과 비교해보자.
\
&nbsp;
### 명령형 프로그래밍 vs 리액티브 프로그래밍
---
> 명령형 프로그래밍 방식은 변경이 발생했는 지 질문해서 응답에 따라 데이터를 가져오는 pull 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(push) 방식이다.

* **Push 방식(리액티브 프로그래밍)** : 데이터의 변화가 발생했을 때 변경이 발생한 곳에서 데이터를 보내주는 방식
    * RTC(Real Time Communication)
    * 소켓 프로그래밍
    * DB Trigger
    * Spring의 ApplicationEvent
    * Angular의 데이터 바인딩
    * 스마트폰의 Push 메시지
* **Pull 방식** : 변경된 데이터가 있는지 요청을 보내 질의하고 변경된 데이터를 가져오는 방식
    * 클라이언트 요청 & 서버 응답 방식의 애플리케이션
    * Java와 같은 절차형 프로그래밍 언어


### 리액티브 프로그래밍 장점
---
> 리액티브 프로그래밍을 이용하면 비동기처리를 쉽게 구현할 수 있다


리액티브 프로그래밍에서 데이터를 생산하는 측은 데이터를 전달하는 것까지만 책임진다. 그러므로 데이터를 생산하는 측은 데이터를 소비하는 측이 전달받은 데이터로 무엇을 하는 지는 몰라도 된다. 또한, 데이터를 생산하는 측은 데이터를 소비하는 측에서 무엇을 하든지 관계가 없으므로 소비하는 측의 처리를 기다릴 필요가 없다. 그러므로 데이터를 통지한 후 데이터를 소비하는 측에서 데이터를 처리하는 도중이라도 데이터를 생산하는 측은 바로 다음 데이터를 처리할 수 있다. 이처럼 비동기 처리를 쉽게 구현 가능하다.
\
&nbsp;
\
&nbsp;
## 리액티브 프로그래밍을 위해 알아야 될 것들
***

리액티브 프로그래밍을 더 잘 이해하기 위해 알아두면 좋은 내용들을 정리해보았다.

* Observable : 데이터 소스 (변경되는 데이터 관찰)
* 리액티브 연산자(Operators) : 데이터 소스를 처리하는 함수
* 스케쥴러(Scheduler) : 스레드 관리자
* Subscriber : Observable이 발행하는 데이터를 구독하는 구독자
* 함수형 프로그래밍 : RxJava에서 제공하는 연산자(Operator) 함수를 사용
* doOnNext : 데이터가 발생한 후 onNext 함수가 호출된 후 호출되는 메소드
* subscribeOn : 데이터가 발행, 데이터의 흐름을 결정짓는 스레드를 결정
* observeOn : 발행된 데이터를 가공하고 구독해서 처리하는 스레드를 결정
* 리액티브 기본 동작 흐름 : 데이터 발행 -> 데이터 가공 -> 데이터 구독 -> 결과 처리

\
&nbsp;
## RxJava의 특징
***

다시 RxJava로 돌아와 RxJava의 특징을 살펴보면 다음과 같다.

* 디자인 패턴인 옵저버(Observer)패턴을 잘 확장함
    * 옵저버 패턴은 [**RxJava(3) - Observable**](https://beanie00.github.io/posts/RxJava(3)-Observable/)에서 자세히 다루었다.
* 쉬운 비동기 처리
* 함수형 프로그래밍의 영향을 받아 함수형 인터페이스를 인자로 전달받는 메서드를 사용해 대부분의 처리를 구현

\
&nbsp;
## RxJava를 어떻게 공부하면 좋을까
***

### RxJava 공부가 어려운 이유
---

* 자바는 thread 기반의 프로그래밍인데 반해 RxJava는 비동기 프로그래밍을 위한 라이브러리라서 개념과 접근 방식이 다르다.
    * 전통적인 스레드 기반의 프로그래밍은 다수의 스레드를 활용하는 경우 예상치 못한 문제가 발생하고 디버깅하기도 어려웠다. 특히 문제를 재현하기 어렵거나 미묘한 경우도 상당수 발생한다. 이러한 문제를 해결하기 위해 RxJava는 함수형 프로그래밍 기법을 도입했다. 함수형 프로그래밍은 부수 효과가 없는 순수 함수를 지향하므로 스레드에 안전하다.
    * 자바는 함수형 언어가 아니므로 RxJava 라이브러리는 순수 함수로 작성된 **리액티브 연산자** 를 제공한다. 이 리액티브 연산자 덕분에 RxJava는 리액티브 프로그래밍이 되는 것이다. 리액티브 연산자를 활용하면 목적을 달성할 수 있는 도구인 '함수형 프로그래밍' 방식으로 '스레드에 안전한 비동기 프로그램'을 작성할 수 있다.
* 따라서 함수형 연산자를 어떻게 활용해야할 지 몰라 RxJava를 이용한 코딩에 어려움을 느낄 수 있다.

따라서 다음의 순서로 RxJava를 학습하는 것을 추천한다.
\
&nbsp;
### RxJava 추천 학습 순서
---

1. Observable 클래스를 명확하게 이해
2. map(), filter(), reduce(), flatMap() 등의 함수의 사용법 익히기
3. 생성 연산자, 결합 연산자, 변환 연산자 등 카테고리별 주요 함수를 공부
4. 스케줄러의 의미를 배우고 subscribeOn()과 observeOn() 함수의 차이 알기
5. 그밖의 디버깅, 흐름 제어 함수를 익히기

\
&nbsp;

***

참고 내용 출처 :
  * 인프런 - Kevin의 알기 쉬운 RxJava 1부
  * RxJava 리액티브 프로그래밍
  * [https://12bme.tistory.com/570](https://12bme.tistory.com/570)
